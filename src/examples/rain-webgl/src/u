defineBinaryOperator ('|', (a, b) => b (a))
defineBinaryOperator ('>>', curry ((a, b) => compose (b, a)))
defineBinaryOperator ('<<', curry ((a, b) => compose (a, b)))

import ramda, {
    always, not,
    either, both,
    any, all, allPass, anyPass,
    isEmpty, tap, has, hasIn, flip, fromPairs, toPairs, assoc, assocPath, head,
    tail, reduceRight, chain, identity as id, reduce, map, filter, reject, join,
    split, splitAt, prop, curry, zip, contains,
    forEach as each, forEachObjIndexed as eachObj, complement,
    isNil, addIndex, take, equals, mapAccum, compose, append, concat,
    T, F, repeat as rRepeat, times as rTimes, range,
} from 'ramda'

import {
    ok, ifOk, ifTrue, ifFalse, ifYes, ifNo, ifPredicate, ifEmpty,
    whenOk, whenTrue, whenFalse, whenYes, whenNo, whenPredicate, whenEmpty,
    dot, dot1, dot2, nieuw, nieuw1, nieuw2,
    cond, guard, otherwise,
    sprintf1, sprintfN, times, rangeBy,
    noop, doe, blush,
    concatTo, concatFrom, appendTo, appendFrom, appendToMut,
    invoke, applyN, pass1,
    laat, laatO, laats, laatsO,
    compactOk, compact,
    lt, gt, eq, ne, lte, gte,
  factory, factoryInit,
  side2,
  side3,
} from 'stick'

import * as WebGL from "./webgl";
import GL from "./gl-obj";
import loadImages from "./image-loader";
import createCanvas from "./create-canvas";

const dot4 = curry ((prop, val1, val2, val3, val4, o) => o[prop] (val1, val2, val3, val4))
const side4 = curry (
    (prop, val1, val2, val3, val4) => tap (dot4 (prop) (val1) (val2) (val3) (val4))
)

const createUniform2f = side4 ('createUniform') ('2f')
const createUniform1f = side3 ('createUniform') ('1f')
const createUniform1i = side3 ('createUniform') ('1i')

const createTexture = side2 ('createTexture')

const requireShaderScript = require("glslify");

const vertShader = requireShaderScript('./shaders/simple.vert');
const fragShader = requireShaderScript('./shaders/water.frag');

const defaultOptions = {
  renderShadow: false,
  minRefraction: 256,
  maxRefraction: 512,
  brightness: 1,
  alphaMultiply: 20,
  alphaSubtract: 5,
  parallaxBg: 5,
  parallaxFg: 20
}

const instance = {
  canvas: void 8,
  canvasLiquid: void 8,
  imageFg: void 8,
  imageBg: void 8,
  imageShine: void 8,
  optionsArg: void 8,
}

const proto = {
  gl: void 8,
  width: 0,
  height: 0,
  textures: void 8,
  programWater: void 8,
  parallaxX: 0,
  parallaxY: 0,
  renderShadow: false,
  options: void 8,

  init () {
    this.options = Object.assign({},defaultOptions, this.optionsArg)
    this.width = this.canvas.width
    this.height = this.canvas.height
    this.gl = new GL (this.canvas, { alpha: false }, vertShader, fragShader)

    const { gl, width, height, imageBg, imageShine, options, } = this
    const { renderShadow, minRefraction, maxRefraction, brightness, alphaMultiply, alphaSubtract, parallaxBg, parallaxFg, } = options
    const { width: ibWidth, height: ibHeight } = imageBg
    this.programWater = gl.program

    gl | createUniform2f ('resolution', width, height)
       | createUniform1f ('textureRatio', width / height)
       | createUniform1i ('renderShine', imageShine | ok)
       | createUniform1i ('renderShadow', renderShadow)
       | createUniform1f ('minRefraction', minRefraction)
       | createUniform1f ('refractionDelta', maxRefraction-minRefraction)
       | createUniform1f ('brightness', brightness)
       | createUniform1f ('alphaMultiply', alphaMultiply)
       | createUniform1f ('alphaSubtract', alphaSubtract)
       | createUniform1f ('parallaxBg', parallaxBg)
       | createUniform1f ('parallaxFg', parallaxFg)
       | createTexture (null,  0)

    const textures = [
      {
        name: 'textureShine',
        img: imageShine | ifOk (
          id,
          _ => createCanvas (2, 2),
        ),
      },
      { name: 'textureFg', img: this.imageFg },
      { name: 'textureBg', img: this.imageBg }
    ];

    this.textures=[
      {name:'textureShine', img:this.imageShine==null?createCanvas(2,2):this.imageShine},
      {name:'textureFg', img:this.imageFg},
      {name:'textureBg', img:this.imageBg}
    ];

    this.textures.forEach((texture,i)=>{
      gl.createTexture(texture.img,i+1);
      gl.createUniform("1i",texture.name,i+1);
    });

    this.draw();
    return this
  },

  draw(){
    this.gl.useProgram(this.programWater);
    this.gl.createUniform("2f", "parallax", this.parallaxX,this.parallaxY);
    this.updateTexture();
    this.gl.draw();

    requestAnimationFrame(this.draw.bind(this));
  },
  updateTextures(){
    this.textures.forEach((texture,i)=>{
      this.gl.activeTexture(i+1);
      this.gl.updateTexture(texture.img);
    })
  },
  updateTexture(){
    this.gl.activeTexture(0);
    this.gl.updateTexture(this.canvasLiquid);
  },
  resize(){
  },
  get overlayTexture(){
  },
  set overlayTexture(v){
  }
}

export default proto | factory | factoryInit (instance)
