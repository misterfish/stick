<!DOCTYPE html>
<html>
  <head>
    <title>Usage</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link type="text/css" rel="stylesheet" href="assets/style.css" />
    <link type="text/css" rel="stylesheet" href="assets/pilcrow.css" />
    <link type="text/css" rel="stylesheet" href="assets/hljs-github.min.css"/>
  </head>
<body><h3 id="usage"><a class="header-link" href="#usage"></a>Usage</h3>
<h4 id="٭-node"><a class="header-link" href="#٭-node"></a>٭ node</h4>
<pre class="hljs"><code>npm i stick-js <span class="hljs-comment"># or yarn</span>

cat &gt;.babelrc &lt;&lt;EOT
{<span class="hljs-string">"presets"</span>: [<span class="hljs-string">"babel-preset-es2015"</span>, <span class="hljs-string">"stage-0"</span>], <span class="hljs-string">"plugins"</span>: [
    <span class="hljs-string">"babel-plugin-operator-overload"</span>
]}
EOT

node_modules/.bin/babel -d <span class="hljs-class"><span class="hljs-keyword">lib</span> <span class="hljs-title">src</span></span>
node <span class="hljs-class"><span class="hljs-keyword">lib</span>/&lt;<span class="hljs-title">entry</span>-<span class="hljs-title">file</span>&gt;.<span class="hljs-title">js</span></span></code></pre><h4 id="٭-webpack"><a class="header-link" href="#٭-webpack"></a>٭ webpack</h4>
<h5 id="webpack-config:"><a class="header-link" href="#webpack-config:"></a>webpack config:</h5>
<pre class="hljs"><code><span class="hljs-attr">module:</span> {
<span class="hljs-attr">  rules:</span> [
    {
<span class="hljs-attr">      test:</span> /\.js$/,
<span class="hljs-attr">      exclude:</span> /node_modules/,
<span class="hljs-attr">      use:</span> {
<span class="hljs-attr">        loader:</span> <span class="hljs-string">'babel-loader'</span>,
<span class="hljs-attr">        options:</span> {
<span class="hljs-attr">          presets:</span> [[
            <span class="hljs-string">"env"</span>,
            { <span class="hljs-string">"modules"</span>: <span class="hljs-literal">false</span> },
          ]],
<span class="hljs-attr">          plugins:</span> [
            <span class="hljs-string">'operator-overload'</span>,
          ]
        }
      },
    },
    ...
  ]
  ...
  }</code></pre><h3 id="what-we-provide"><a class="header-link" href="#what-we-provide"></a>What we provide</h3>
<ul class="list">
<li><p>A way to start using the pipe (or &#39;stick&#39;) operator today while the
proposal is still being fleshed out. (link)</p>
</li>
<li><p>Note that we use <code>|</code>, not <code>|&gt;</code>, which is not only easier to overload but
far more pleasant to work with, and which will still work even if/when the
proposal is accepted.</p>
</li>
</ul>
<p>If you really want to do bitwise math, see below.</p>
<p>The overloading is made possible thanks to the great
<a href="https://github.com/jussi-kalliokoski/babel-plugin-operator-overload">babel-plugin-operator-overload</a>
library by Jussi Kalliokoski (@jussi-kalliokoski).</p>
<h3 id="features-(/-why?)"><a class="header-link" href="#features-(/-why?)"></a>Features (/ why?)</h3>
<h3 id="synopsis-(overview)."><a class="header-link" href="#synopsis-(overview)."></a>Synopsis (overview).</h3>
<p>Please see X for a more detailed discussion and many more examples.</p>
<h4 id="٭-basic-example-٭"><a class="header-link" href="#٭-basic-example-٭"></a>٭ basic example ٭</h4>
<pre class="hljs"><code><span class="hljs-regexp">//</span> --- header/ source files must begin with <span class="hljs-keyword">this</span> header.

defineBinaryOperator (<span class="hljs-string">'|'</span>,  <span class="hljs-function"><span class="hljs-params">(...args)</span> =&gt;</span> pipe         (...args))
defineBinaryOperator (<span class="hljs-string">'&lt;&lt;'</span>, <span class="hljs-function"><span class="hljs-params">(...args)</span> =&gt;</span> compose      (...args))
defineBinaryOperator (<span class="hljs-string">'&gt;&gt;'</span>, <span class="hljs-function"><span class="hljs-params">(...args)</span> =&gt;</span> composeRight (...args))

<span class="hljs-keyword">import</span> {
    pipe, compose, composeRight,

<span class="hljs-regexp">//</span> --- /header

    map, join,
} <span class="hljs-keyword">from</span> <span class="hljs-string">'stick-js'</span>

<span class="hljs-keyword">import</span> { green, } <span class="hljs-keyword">from</span> <span class="hljs-string">'chalk'</span>

const { log, } = <span class="hljs-built_in">console</span>

; [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
| map (x =&gt; x + <span class="hljs-number">1</span>)
| join (<span class="hljs-string">'/'</span>)
| green
| sprintf1 (<span class="hljs-string">'The answer is %s'</span>)
| log <span class="hljs-regexp">//</span> outputs <span class="hljs-string">'The answer is 2/3/4'</span> (colorfully)</code></pre><h4 id="٭-the-'stick'-operator-٭"><a class="header-link" href="#٭-the-'stick'-operator-٭"></a>٭ the &#39;stick&#39; operator ٭</h4>
<p><code>a | b</code> is simply an equivalent way of writing <code>b (a)</code></p>
<p>A really simple idea, with pretty surprising consequences.</p>
<p>(What if I really want to do bitwise math, you ask? See below).</p>
<pre class="hljs"><code><span class="hljs-comment">// --- reminder: source files must begin with this.</span>
<span class="hljs-comment">// --- from here on out we'll omit it in the examples.</span>
defineBinaryOperator (<span class="hljs-string">'|'</span>,  (...args) =&gt; pipe         (...args))
defineBinaryOperator (<span class="hljs-string">'&lt;&lt;'</span>, (...args) =&gt; compose      (...args))
defineBinaryOperator (<span class="hljs-string">'&gt;&gt;'</span>, (...args) =&gt; composeRight (...args))

<span class="hljs-keyword">import</span> {
  pipe, compose, composeRight,
  map, join, split,
} from <span class="hljs-string">'stick-js'</span>

<span class="hljs-keyword">const</span> multiply = x =&gt; y =&gt; x * y
<span class="hljs-keyword">const</span> <span class="hljs-built_in">double</span> = multiply (<span class="hljs-number">2</span>)     <span class="hljs-comment">// or 2 | multiply</span>

<span class="hljs-number">3</span> | <span class="hljs-built_in">double</span>                      <span class="hljs-comment">// 6</span>
<span class="hljs-built_in">double</span> (<span class="hljs-number">3</span>)                      <span class="hljs-comment">// 6</span>
<span class="hljs-number">3</span> | multiply (<span class="hljs-number">4</span>)                <span class="hljs-comment">// 12</span>

<span class="hljs-keyword">const</span> capitaliseFirstLetter = x =&gt; x[<span class="hljs-number">0</span>].toUpperCase () + x.slice (<span class="hljs-number">1</span>)

<span class="hljs-string">'just a perfect day'</span>
  | split (<span class="hljs-string">' '</span>)                 <span class="hljs-comment">// split (' ') is a function</span>
  | map (capitaliseFirstLetter) <span class="hljs-comment">// map (capitaliseFirstLetter) is a function</span>
  | join (<span class="hljs-string">' '</span>)                  <span class="hljs-comment">// join (' ') is a function</span>
<span class="hljs-comment">// 'Just A Perfect Day'</span></code></pre><h4 id="٭-currying-styles-٭"><a class="header-link" href="#٭-currying-styles-٭"></a>٭ currying styles ٭</h4>
<p>All curried functions provided by stick-js can be called using either of 2 currying styles.</p>
<p>This would be a good time to read XXX if you&#39;re not familiar with curried functions.</p>
<ol class="list">
<li><p>we will refer to this sort of function and calling style as &#39;manual&#39;:</p>
<pre class="hljs"><code> const f = <span class="hljs-selector-tag">a</span> =&gt; <span class="hljs-selector-tag">b</span> =&gt; c =&gt; <span class="hljs-selector-tag">a</span> + <span class="hljs-selector-tag">b</span> + c          <span class="hljs-comment">// call like f (1) (2) (3)</span></code></pre></li>
<li><p>and this sort as &#39;normal&#39;:</p>
<pre class="hljs"><code> const g = R<span class="hljs-selector-class">.curry</span> ((<span class="hljs-selector-tag">a</span>, <span class="hljs-selector-tag">b</span>, c) =&gt; <span class="hljs-selector-tag">a</span> + <span class="hljs-selector-tag">b</span> + c) <span class="hljs-comment">// call like f (1) (2) (3) or f (1, 2, 3)</span>
                                            <span class="hljs-comment">// or f (1, 2, 3)</span>
                                            <span class="hljs-comment">// or f (1) (2, 3)</span>
                                            <span class="hljs-comment">// etc.</span></code></pre></li>
</ol>
<pre class="hljs"><code><span class="hljs-keyword">import</span> { <span class="hljs-built_in">map</span>, } from <span class="hljs-string">'stick-js'</span>

<span class="hljs-built_in">map</span> (<span class="hljs-keyword">double</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])    <span class="hljs-comment">// [2, 4, 6] (normal style)</span>
<span class="hljs-built_in">map</span> (<span class="hljs-keyword">double</span>) ([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])   <span class="hljs-comment">// [2, 4, 6] (manual style)</span>
; [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] | <span class="hljs-built_in">map</span> (<span class="hljs-keyword">double</span>) <span class="hljs-comment">// [2, 4, 6] (manual style with stick)</span></code></pre><p>For extra performance you can also limit yourself to the manual style (see
below).</p>
<h4 id="٭-markers-٭"><a class="header-link" href="#٭-markers-٭"></a>٭ markers ٭</h4>
<pre class="hljs"><code><span class="hljs-keyword">import</span> { sprintfN, sprintf1, } <span class="hljs-keyword">from</span> <span class="hljs-string">'stick-js'</span>

<span class="hljs-number">3</span> | sprintf1 (<span class="hljs-string">'4 - 1 is %s'</span>) <span class="hljs-comment">// '4 - 1 is 3'</span></code></pre><p>&#39;N&#39; is a marker meaning an array is expected.</p>
<pre class="hljs"><code>; <span class="hljs-selector-attr">[4, 3]</span>
| <span class="hljs-selector-tag">sprintfN</span> (<span class="hljs-string">'%s - 1 is %s'</span>)  <span class="hljs-comment">// same.</span></code></pre><p>&#39;V&#39; means a value is expected, to disambiguate cases where a function can also work.</p>
<pre class="hljs"><code>import { timesV, timesF, } from 'stick-js'

const { <span class="hljs-built_in">random</span>, } = Math

<span class="hljs-number">3</span>      | timesV (<span class="hljs-number">4</span>)          // [<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>]
<span class="hljs-built_in">random</span> | timesF (<span class="hljs-number">4</span>)          // [&lt;<span class="hljs-built_in">random</span>-<span class="hljs-built_in">num</span>&gt;, &lt;<span class="hljs-built_in">random</span>-<span class="hljs-built_in">num</span>&gt;, &lt;<span class="hljs-built_in">random</span>-<span class="hljs-built_in">num</span>&gt;, &lt;<span class="hljs-built_in">random</span>-<span class="hljs-built_in">num</span>&gt;]</code></pre><p>&#39;M&#39; means the data is being mutated. In JS we absolutely can not pretend
everything is immutable.</p>
<pre class="hljs"><code>import { appendTo, appendToM, } from 'stick-js'
<span class="hljs-built_in">
const </span>a = [1, 2, 3]<span class="hljs-built_in">
const </span>b = 4 | appendTo (a) // functional style: the<span class="hljs-built_in"> array </span>is cloned.
b === a // false
<span class="hljs-built_in">
const </span>a = [1, 2, 3]<span class="hljs-built_in">
const </span>b = 4 | appendToM (a) // non-functional style: the<span class="hljs-built_in"> array </span>is mutated.
b === a // true
<span class="hljs-built_in">
const </span>webGLContext = { ... a complicated object ... }
webGLContext | mergeM ({ someProp: false, }) // you definitely want mutable here.</code></pre><p>And there are a few more which we&#39;ll see along the way.</p>
<h4 id="٭-ok,-anaphoric-if-٭"><a class="header-link" href="#٭-ok,-anaphoric-if-٭"></a>٭ ok, anaphoric if ٭</h4>
<p><code>ok (x)</code> is false if <code>x</code> is <code>null</code> or <code>undefined</code>. Everything else passes.</p>
<pre class="hljs"><code><span class="hljs-keyword">import</span> { <span class="hljs-built_in">map</span>, ok, notOk, ifOk, } from <span class="hljs-string">'stick-js'</span>

const { <span class="hljs-keyword">log</span>, } = console

; <span class="hljs-meta">[</span><span class="hljs-number">0</span>, <span class="hljs-literal">false</span>, <span class="hljs-string">''</span>, <span class="hljs-built_in">null</span>, <span class="hljs-literal">void</span> <span class="hljs-number">8</span><span class="hljs-meta">]</span>
| map (ok)    // <span class="hljs-meta">[</span><span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span><span class="hljs-meta">]</span>

; <span class="hljs-meta">[</span><span class="hljs-number">0</span>, <span class="hljs-literal">false</span>, <span class="hljs-string">''</span>, <span class="hljs-built_in">null</span>, <span class="hljs-literal">void</span> <span class="hljs-number">8</span><span class="hljs-meta">]</span>
| map (notOk) // <span class="hljs-meta">[</span><span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span><span class="hljs-meta">]</span></code></pre><p>Something we see a lot in JS in the wild is:</p>
<pre class="hljs"><code><span class="hljs-keyword">let</span> answer
<span class="hljs-keyword">if</span> (someVar !== <span class="hljs-literal">undefined</span> &amp;&amp; someVar !== <span class="hljs-literal">null</span>) {
  answer = someVar + <span class="hljs-number">1</span>
} <span class="hljs-keyword">else</span> {
  answer = <span class="hljs-string">'nothing'</span>
}</code></pre><p>This can vastly improved using an &#39;anaphoric if&#39; and a stick idiom.
<code>ifOk</code> takes two functions -- a &#39;then&#39; function and an &#39;else&#39; function.
In the &#39;ok&#39;    case, the value being tested is passed to the function.</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> add1IfYouCan = val =&gt; val | ifOk (
  <span class="hljs-comment">// `that` is here `val`</span>
  that =&gt; that + <span class="hljs-number">1</span>,

  <span class="hljs-comment">// no value is passed.</span>
  _ =&gt; <span class="hljs-string">'nothing'</span>,
)</code></pre><p>A variant, using a point-free add function and the <code>always</code> function:</p>
<pre class="hljs"><code><span class="hljs-keyword">import</span> { add, always, } <span class="hljs-keyword">from</span> <span class="hljs-string">'stick-js'</span>

<span class="hljs-keyword">const</span> add1 = <span class="hljs-number">1</span> | add <span class="hljs-comment">// or add (1)</span>

<span class="hljs-keyword">const</span> add1IfYouCan = <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x | ifOk (
  add1,
  <span class="hljs-string">'nothing'</span> | always,
)</code></pre><p>Usage:</p>
<pre class="hljs"><code>; <span class="hljs-meta">[</span><span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-built_in">null</span>, <span class="hljs-literal">void</span> <span class="hljs-number">8</span><span class="hljs-meta">]</span>
| map (add1IfYouCan) // <span class="hljs-meta">[</span><span class="hljs-number">1</span>, <span class="hljs-number">11</span>, <span class="hljs-string">'nothing'</span>, <span class="hljs-string">'nothing'</span><span class="hljs-meta">]</span></code></pre><h4 id="٭-point-free-٭"><a class="header-link" href="#٭-point-free-٭"></a>٭ point-free ٭</h4>
<p>A common pattern is when the argument to a function is passed directly into a pipe:</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> add1IfYouCan = <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x | ifOk (add1, <span class="hljs-string">'nothing'</span> | always)</code></pre><p>Since <code>x</code> does not appear anywhere else in the expression, we can simply remove it:</p>
<pre class="hljs"><code>const add1IfYouCan = ifOk (<span class="hljs-name">add1</span>, 'nothing' | always)</code></pre><p>If the pipe chain consists of more than 1 link …</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> { dot, sprintf1, tap, }
<span class="hljs-keyword">const</span> { log, } = <span class="hljs-built_in">console</span>

<span class="hljs-keyword">const</span> add1IfYouCan = <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x
  | ifOk (add1, <span class="hljs-string">'nothing'</span> | always)
  | <span class="hljs-built_in">String</span>                          <span class="hljs-comment">// type conversions are easy using type constructors by the way</span>
  | dot (<span class="hljs-string">'toUpperCase'</span>)
  | sprintf1 (<span class="hljs-string">'The answer is %s'</span>)
  | tap (log)                     <span class="hljs-comment">// outputs 'The answer is 1' or 'The answer is NOTHING' or ...</span></code></pre><p>… then we remove the <code>x =&gt; x</code> and change all the <code>|</code> to <code>&gt;&gt;</code></p>
<pre class="hljs"><code>const add1IfYouCan =
  ifOk (<span class="hljs-name">add1</span>, 'nothing' | always)
  &gt;&gt; String
  &gt;&gt; dot ('toUpperCase')
  &gt;&gt; sprintf1 ('The answer is %s')
  &gt;&gt; tap (<span class="hljs-name">log</span>)</code></pre><h4 id="٭-compositional-predicates-٭"><a class="header-link" href="#٭-compositional-predicates-٭"></a>٭ compositional predicates ٭</h4>
<p><code>ifOk</code> is a convenience for <code>ifPredicate (ok)</code> or <code>ok | ifPredicate</code>.</p>
<p>There is also a &#39;when&#39; form, which has no &#39;else branch&#39;.</p>
<pre class="hljs"><code>import { <span class="hljs-keyword">add</span>, whenOk, } <span class="hljs-keyword">from</span> <span class="hljs-string">'stick-js'</span>

<span class="hljs-keyword">const</span> add1 = <span class="hljs-number">1</span> | <span class="hljs-keyword">add</span> <span class="hljs-comment">// or add (1)</span>

<span class="hljs-number">3</span>    | whenOk (add1) <span class="hljs-comment">// 4</span>
<span class="hljs-literal">null</span> | whenOk (add1) <span class="hljs-comment">// undefined</span></code></pre><p>The selection of <code>if</code> and <code>when</code> functions we provide is intentionally skimpy, to encourage you to compose your own.</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> { <span class="hljs-built_in">floor</span>, } = Math

<span class="hljs-comment">// --- predicate to match integers.</span>
<span class="hljs-keyword">const</span> isInteger = x =&gt; x === <span class="hljs-built_in">floor</span> (x)

<span class="hljs-comment">// --- or how about</span>
<span class="hljs-comment">// import { eq, } from 'stick-js'</span>
<span class="hljs-comment">// const isInteger = x =&gt; x | floor | eq (x)</span>

<span class="hljs-comment">// --- or if you're getting bored:</span>
<span class="hljs-comment">// import { timesV, asterisk, passToN, } from 'stick-js'</span>
<span class="hljs-comment">// const arrowSnd = f =&gt; timesV (2) &gt;&gt; asterisk ([id, f])</span>
<span class="hljs-comment">// const isInteger = arrowSnd (floor) &gt;&gt; passToN (eq)</span>

<span class="hljs-comment">// --- now compose it into an anaphoric if:</span>

<span class="hljs-keyword">const</span> ifInteger = isInteger | ifPredicate

<span class="hljs-keyword">const</span> add1 = <span class="hljs-built_in">add</span> (<span class="hljs-number">1</span>)

; [<span class="hljs-number">3.5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4.2</span>]
| <span class="hljs-built_in">map</span> (ifInteger (add1, <span class="hljs-string">'nothing'</span> | always))
  <span class="hljs-comment">// ['nothing', 5, 'nothing']</span></code></pre><p>More complicated predicates:</p>
<pre class="hljs"><code><span class="hljs-comment">// --- @todo use `allN`</span>
<span class="hljs-keyword">const</span> both = <span class="hljs-function">(<span class="hljs-params">f, g</span>) =&gt;</span> x =&gt; f (x) &amp;&amp; g (x) ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>

<span class="hljs-keyword">const</span> isOdd = <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x % <span class="hljs-number">2</span>

<span class="hljs-keyword">const</span> isOddInteger = both (isInteger, isOdd)
<span class="hljs-keyword">const</span> ifOddInteger = isOddInteger | ifPredicate

; [<span class="hljs-number">3.5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5.5</span>]
| map (ifOddInteger (
  add1,
  <span class="hljs-string">'nothing'</span> | always,
))
| log

; [<span class="hljs-number">3.5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5.5</span>] | map (isOddInteger) | log</code></pre><h4 id="٭-compositional-decoration-٭"><a class="header-link" href="#٭-compositional-decoration-٭"></a>٭ compositional decoration ٭</h4>
<p>Our <code>map</code> function is capped at one argument, meaning the map routine only
gets the value and not the index or the collection.</p>
<pre class="hljs"><code><span class="hljs-keyword">import</span> { map, addIndex, addCollection, } <span class="hljs-keyword">from</span> <span class="hljs-string">'stick-js'</span>

; [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]
| map (<span class="hljs-function"><span class="hljs-params">(x, idx)</span> =&gt;</span> idx) <span class="hljs-regexp">//</span> [<span class="hljs-literal">undefined</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-literal">undefined</span>]</code></pre><p>But:</p>
<pre class="hljs"><code>const mapWithIndex = map | <span class="hljs-type">addIndex</span>
; [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]
| <span class="hljs-type">mapWithIndex</span> ((x, idx) =&gt; idx) // [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]

const mapWithCollection = map | <span class="hljs-type">addCollection</span>
; [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]
| <span class="hljs-type">mapWithCollection</span> ((x, coll) =&gt; coll) // [[<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]]

; [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]
| <span class="hljs-type">(map</span> | <span class="hljs-type">addIndex</span> | <span class="hljs-type">addCollection</span>) ((x, idx, coll) =&gt; ...)

; [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]
| <span class="hljs-type">(map</span> | <span class="hljs-type">addCollection</span> | <span class="hljs-type">addIndex</span>) ((x, coll, idx) =&gt; ...)</code></pre><p>We can also enhance our merge functions, to deal with conflicts:</p>
<pre class="hljs"><code><span class="hljs-keyword">import</span> { mergeWith, mergeToSym, } <span class="hljs-keyword">from</span> <span class="hljs-string">'stick-js'</span>

<span class="hljs-keyword">const</span> chooseTgt = <span class="hljs-function">(<span class="hljs-params">src, tgt</span>) =&gt;</span> tgt
<span class="hljs-keyword">const</span> chooseSrc = <span class="hljs-function">(<span class="hljs-params">src, tgt</span>) =&gt;</span> src

<span class="hljs-comment">// --- choose target value on conflict</span>
<span class="hljs-keyword">const</span> mergeChooseTgt = mergeToSym | mergeWith (chooseTgt)

<span class="hljs-comment">// --- choose source value on conflict</span>
<span class="hljs-keyword">const</span> mergeChooseSrc = mergeToSym | mergeWith (chooseSrc)

<span class="hljs-keyword">const</span> os = { <span class="hljs-attr">name</span>: <span class="hljs-string">'source name'</span>, }
<span class="hljs-keyword">const</span> ot = { <span class="hljs-attr">name</span>: <span class="hljs-string">'target name'</span>, }

os | mergeChooseSrc (ot) <span class="hljs-comment">// 'source name'</span>
os | mergeChooseTgt (ot) <span class="hljs-comment">// 'target name'</span></code></pre><p>Or to only merge if certain conditions hold:</p>
<pre class="hljs"><code>import { mergeWhen, eq, } from <span class="hljs-string">'stick-js'</span>

const { <span class="hljs-built_in">floor</span>, } = Math
const isInteger = <span class="hljs-keyword">x</span> =&gt; <span class="hljs-keyword">x</span> | <span class="hljs-built_in">floor</span> | eq (<span class="hljs-keyword">x</span>)
const srcIsInteger = (src, tgt) =&gt; src | isInteger
const mergeToWhenSrcIsInteger = mergeToSym | mergeWhen (srcIsInteger)

const os = { va<span class="hljs-variable">l:</span> <span class="hljs-number">2.2</span>, <span class="hljs-keyword">vi</span><span class="hljs-variable">l:</span> <span class="hljs-number">3</span>,  vo<span class="hljs-variable">l:</span> <span class="hljs-number">3.5</span>, }
const ot = { va<span class="hljs-variable">l:</span> <span class="hljs-number">25</span>,  <span class="hljs-keyword">vi</span><span class="hljs-variable">l:</span> <span class="hljs-number">25</span>, vo<span class="hljs-variable">l:</span> <span class="hljs-number">25</span>,  <span class="hljs-keyword">ve</span><span class="hljs-variable">l:</span> <span class="hljs-number">42</span>, }

os | mergeTo (ot)                 // { va<span class="hljs-variable">l:</span> <span class="hljs-number">2.2</span>, <span class="hljs-keyword">vi</span><span class="hljs-variable">l:</span> <span class="hljs-number">3</span>, vo<span class="hljs-variable">l:</span> <span class="hljs-number">3.5</span>, <span class="hljs-keyword">ve</span><span class="hljs-variable">l:</span> <span class="hljs-number">42</span>, }
os | mergeToWhenSrcIsInteger (ot) // { va<span class="hljs-variable">l:</span> <span class="hljs-number">25</span>,  <span class="hljs-keyword">vi</span><span class="hljs-variable">l:</span> <span class="hljs-number">3</span>, vo<span class="hljs-variable">l:</span> <span class="hljs-number">25</span>,  <span class="hljs-keyword">ve</span><span class="hljs-variable">l:</span> <span class="hljs-number">42</span>, }</code></pre><p>| log</p>
<h4 id="٭-semantics-and-argument-order-are-often-derivable-by-thinking-in-english-٭"><a class="header-link" href="#٭-semantics-and-argument-order-are-often-derivable-by-thinking-in-english-٭"></a>٭ semantics and argument order are often derivable by thinking in English ٭</h4>
<p>(We&#39;re dying to see a port to Hungarian, too)</p>
<pre class="hljs"><code>import {
  sprintfN, sprintf1, mergeTo, merge, prependTo, prepend,
  appendTo, append, <span class="hljs-built_in">bind</span>PropTo, <span class="hljs-built_in">bind</span>Prop, <span class="hljs-built_in">bind</span>To, <span class="hljs-built_in">bind</span>, invoke,
} from <span class="hljs-string">'stick-js'</span>

const obj1 = { thing: <span class="hljs-string">'sandwich'</span>, want: <span class="hljs-string">'no thanks'</span>,  }
const obj2 = {                    want: <span class="hljs-string">'yes please'</span>, }</code></pre><p>When a function ends in &#39;To&#39;, (the) identifier to the right is the object of
the preposition.</p>
<p>Read this as ‘merge obj2 <strong>to obj1</strong>’</p>
<pre class="hljs"><code>obj2 <span class="hljs-string">| mergeTo (obj1)</span></code></pre><p>The same function without the &#39;To&#39; means that the identifier is the object of the verb &#39;merge&#39;.</p>
<p>Read this as: ‘<strong>merge obj2</strong> to obj1’</p>
<pre class="hljs"><code>obj1 | merge (obj2)

4 | appendTo ([1, 2, 3])
; ([1, 2, 3]) | append (4)

0 | prependTo ([1, 2, 3])
; ([1, 2, 3]) | prepend (0)
<span class="hljs-built_in">
const </span>dog = {
  name: 'Caesar',
  speak () {<span class="hljs-built_in"> return </span>'My name is ' + this.name },
}
<span class="hljs-built_in">
const </span>cat = {
  name: 'Bo',
  speak () {<span class="hljs-built_in"> throw </span>new Error },
}
<span class="hljs-built_in">
const </span>f = 'speak' | bindPropTo (dog)
f ()                                  // 'My name is Caesar'

'speak' | bindPropTo (dog)   |<span class="hljs-built_in"> invoke </span>// same
dog     | bindProp ('speak') |<span class="hljs-built_in"> invoke </span>// same

dog.speak | bindTo (dog) |<span class="hljs-built_in"> invoke </span>    // same

// cat.speak ()                          // Error
dog.speak | bindTo (cat) |<span class="hljs-built_in"> invoke </span>    // 'My name is Bo'
cat | bind (dog.speak)   |<span class="hljs-built_in"> invoke </span>    // 'My name is Bo'</code></pre><h4 id="٭-side-effects-&-chaining,-mutable-vs-immutable-٭"><a class="header-link" href="#٭-side-effects-&-chaining,-mutable-vs-immutable-٭"></a>٭ side effects &amp; chaining, mutable vs immutable ٭</h4>
<p>defineBinaryOperator (&#39;|&#39;,  (...args) =&gt; pipe         (...args))
defineBinaryOperator (&#39;&lt;&lt;&#39;, (...args) =&gt; compose      (...args))
defineBinaryOperator (&#39;&gt;&gt;&#39;, (...args) =&gt; composeRight (...args))</p>
<p>import {
  pipe, compose, composeRight,
  map, side1, appendM, append, prependM, prepend,
} from &#39;stick-js&#39;</p>
<p>// --- chaining with the . will often not do what you want.</p>
<p>; [2, 3, 4]
  .push (5)
  .unshift (1) // error, return value of previous line was 5</p>
<p>// --- this will:</p>
<p>const push    = &#39;push&#39; | side1
const unshift = &#39;unshift&#39; | side1</p>
<p>; [2, 3, 4]
| push (5)
| unshift (1) // [1, 2, 3, 4, 5]</p>
<p>// --- using stick functions for mutable data:</p>
<p>; [2, 3, 4]
| appendM (5)
| prependM (1)</p>
<p>// --- using stick functions for immutable data:</p>
<p>; [2, 3, 4]
| append (5)  // new array [2, 3, 4, 5]
| prepend (1) // new array [1, 2, 3, 4, 5]</p>
<h4 id="٭-dog-٭"><a class="header-link" href="#٭-dog-٭"></a>٭ dog ٭</h4>
<h4 id="٭-this-example-is-intentionally-complex-٭"><a class="header-link" href="#٭-this-example-is-intentionally-complex-٭"></a>٭ this example is intentionally complex ٭</h4>
<p><img src="https://placehold.it/15/f03c15/000000?text=hello" alt="#f03c15"> <code>#f03c15</code></p>
<pre class="hljs"><code>yarn <span class="hljs-built_in">add</span> ramda chalk

---

defineBinaryOperator (<span class="hljs-string">'|'</span>,  (...args) =&gt; pipe         (...args))
defineBinaryOperator (<span class="hljs-string">'&lt;&lt;'</span>, (...args) =&gt; compose      (...args))
defineBinaryOperator (<span class="hljs-string">'&gt;&gt;'</span>, (...args) =&gt; composeRight (...args))

<span class="hljs-keyword">import</span> {
  pipe, compose, composeRight,
  recurry, <span class="hljs-built_in">map</span>, <span class="hljs-built_in">join</span>, condS, guard, otherwise,
  sprintfN, rangeTo, lt, gt,
  tap, appendTo, prop,
} from <span class="hljs-string">'stick-js'</span>

<span class="hljs-keyword">import</span> {
  curry,
} from <span class="hljs-string">'ramda'</span>

<span class="hljs-keyword">import</span> {
  yellow, <span class="hljs-built_in">green</span>, <span class="hljs-built_in">red</span>,
} from <span class="hljs-string">'chalk'</span>

<span class="hljs-keyword">const</span> { <span class="hljs-built_in">log</span>, } = console

<span class="hljs-keyword">const</span> cmpStr = curry ((<span class="hljs-built_in">str</span>, <span class="hljs-built_in">color</span>, tgtStr, x) =&gt; [x, <span class="hljs-built_in">str</span> | <span class="hljs-built_in">color</span>, tgtStr]
  | sprintfN (<span class="hljs-string">'%s is %s %s'</span>)
)

<span class="hljs-keyword">const</span> lessThanStr     = cmpStr (<span class="hljs-string">'less than'</span>, yellow)
<span class="hljs-keyword">const</span> greaterThanStr  = cmpStr (<span class="hljs-string">'greater than'</span>, <span class="hljs-built_in">red</span>)
<span class="hljs-keyword">const</span> inBetweenString = ([ low, high ]) =&gt; cmpStr (<span class="hljs-string">'in between'</span>, <span class="hljs-built_in">green</span>, [low, high] | <span class="hljs-built_in">join</span> (<span class="hljs-string">' and '</span>))

<span class="hljs-keyword">const</span> getCmpStr = curry ((low, high, x) =&gt; x
  | condS ([
    low | lt | guard ((low | lessThanStr) &gt;&gt; appendTo ([<span class="hljs-number">-1</span>])),
    high | gt | guard ((high | greaterThanStr) &gt;&gt; appendTo ([<span class="hljs-number">1</span>])),
    otherwise | guard (inBetweenString ([low, high]) &gt;&gt; appendTo ([<span class="hljs-number">0</span>])),
  ])
)

<span class="hljs-keyword">const</span> inRange = ([low, high]) =&gt; x =&gt; getCmpStr (low, high, x)

<span class="hljs-keyword">const</span> snd = prop (<span class="hljs-number">1</span>)
<span class="hljs-keyword">const</span> fst = prop (<span class="hljs-number">0</span>)

<span class="hljs-number">10</span> | rangeTo (<span class="hljs-number">20</span>)             <span class="hljs-comment">// [10, 11, ... 19]</span>
   | <span class="hljs-built_in">map</span> (inRange ([<span class="hljs-number">13</span>, <span class="hljs-number">17</span>])) <span class="hljs-comment">// maps to tuples of [int, str]</span>
   | tap (<span class="hljs-built_in">map</span> (snd &gt;&gt; <span class="hljs-built_in">log</span>))   <span class="hljs-comment">// logs the str</span>
   | <span class="hljs-built_in">map</span> (fst)                <span class="hljs-comment">// [-1, -1, ... 0, ... 1, 1]</span></code></pre><h3 id="performance"><a class="header-link" href="#performance"></a>performance</h3>
<p>Stick is fast. See here for a benchmark of our factory example.</p>
<p>Stick is much faster than Ramda. Though it initially depended on
Ramda, we have decided to eliminate that dependency by reimplementing many
of the functions. While profiling the WebGL example we found that even
trivial functions like <code>R.flip</code> and <code>R.tap</code> are surprisingly expensive.</p>
<p>This really only becomes an issue in tight loops -- an inner loop of a
socket or server, an animation, a particle system where lots of objects are
spawned per second, WebGL. For cases like these, see below.</p>
<p>It is true that <code>a | b</code> compiles to three function calls, whereas <code>b (a)</code> is
only one. But this is almost certainly not going to affect your app. Your JS
runtime can call <em>a lot</em> of functions per millisecond.</p>
<p>Nonetheless you are encouraged to mix and match our functions with whichever
functional libraries you like -- Ramda, Lodash/FP, or anything else, as it
suits you.</p>
<pre class="hljs"><code><span class="hljs-keyword">import</span> { map, } <span class="hljs-keyword">from</span> <span class="hljs-string">'ramda'</span>
<span class="hljs-keyword">import</span> { filter, } <span class="hljs-keyword">from</span> <span class="hljs-string">'lodash/fp'</span>
<span class="hljs-keyword">import</span> { ifPredicate, } <span class="hljs-keyword">from</span> <span class="hljs-string">'stick-js'</span></code></pre><p>The stick idiom will still work, as long as the functions are curried and
data-last.</p>
<p>Furthermore Ramda is probably perfectly fine for your app, and its functions
often provide type-checking and error messages (we don&#39;t), and many of their
functions are more sophisticated. <code>R.map</code> works on functors and
transformers, for example -- ours doesn&#39;t.</p>
<p>And, it is our belief that if you are already using the <code>flow</code> pattern in
Lodash/FP or the <code>pipe</code> function in Ramda, that it will really be a
no-brainer to overload the operator and keep everything else the same.</p>
<pre class="hljs"><code><span class="hljs-symbol">_</span>.flow (
  <span class="hljs-symbol">_</span>.<span class="hljs-built_in">split</span> (' '),
  <span class="hljs-symbol">_</span>.<span class="hljs-built_in">map</span> (capitaliseFirstLetter),
  <span class="hljs-symbol">_</span>.<span class="hljs-built_in">join</span> (' '),
) (myData)

// -&gt;
myData
| <span class="hljs-symbol">_</span>.<span class="hljs-built_in">split</span> (' '),
| <span class="hljs-symbol">_</span>.<span class="hljs-built_in">map</span> (capitaliseFirstLetter),
| <span class="hljs-symbol">_</span>.<span class="hljs-built_in">join</span> (' ')</code></pre><p>merge benchmark: manual / index / ramda</p>
<h3 id="extra-performance"><a class="header-link" href="#extra-performance"></a>Extra performance</h3>
<p>For speed freaks: the curried functions you import from the main module are
written first using manual currying, and then recurried and exported. This
is in order to allow both calling styles.</p>
<p>For a speed boost you can check the docs to see if your function is exported
by &#39;stick-js/manual&#39;. If so, you can directly import the manual version, but
you must remember to call it using the manual style:</p>
<pre class="hljs"><code>import { merge, } from <span class="hljs-string">'stick-js/manual'</span>
merge <span class="hljs-comment">(obj1, obj2)</span> <span class="hljs-comment">// will not work</span>
obj<span class="hljs-number">2</span> | merge <span class="hljs-comment">(obj1)</span> <span class="hljs-comment">// ok</span>
merge <span class="hljs-comment">(obj1)</span> <span class="hljs-comment">(obj2)</span> <span class="hljs-comment">// also ok</span></code></pre><h3 id="bitwise-math"><a class="header-link" href="#bitwise-math"></a>Bitwise math</h3>
<p>Of course, we&#39;ve saved your precious bitwise operators. You can either:</p>
<ol class="list">
<li><p>Use the functional form</p>
<pre class="hljs"><code> <span class="hljs-keyword">import</span> { bitwiseOr, bitwiseShiftBy, } <span class="hljs-keyword">from</span> <span class="hljs-string">'stick-js'</span>
 <span class="hljs-number">4</span> | bitwiseOr (<span class="hljs-number">9</span>) <span class="hljs-comment">// 13</span></code></pre></li>
<li><p>Do your bitwise math in a separate scope than that in which the
<code>defineBinaryOperator</code> calls appear. The operators are only overloaded in
the scope in which the calls are made. We recommend doing the bitwise math
in a separate source file and not mixing the two styles in one file.</p>
</li>
</ol>
<h3 id="why-not-use-lodash?"><a class="header-link" href="#why-not-use-lodash?"></a>Why not use lodash?</h3>
<ul class="list">
<li>you don&#39;t need to carry around the _</li>
<li>free functions are far more flexible than dotted ones</li>
<li>predictable semantics based on English</li>
<li>prototype stuff</li>
</ul>
</body>
</html>
