{"version":3,"sources":["../index.js"],"names":[],"mappings":";;;;;;;;AAAA;AACA,SAAS,aAAT,GAAyB;AACvB,OAAK,KAAL;AACD;;AAED,cAAc,SAAd,GAA0B;AACxB,YAAU,oBAAW;AACnB,WAAO,wBAAP;AACD,GAHuB;AAIxB;AACA;AACA;AACA,SAAO,eAAU,KAAV,EAAkB;AACvB;AACA;AACA,QAAK,UAAU,KAAK,UAApB,EAAiC;AAC/B,aAAO,KAAK,SAAZ;AACD;;AAED,QAAI,IAAI,MAAM,MAAd;AACA,QAAI,OAAO,EAAX;AACA,QAAI,YAAY,EAAhB;AACA,QAAI,eAAe,EAAnB;;AAEA,SAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,CAApB,EAAuB,GAAvB,EAA4B;AAC1B,UAAI,MAAM,MAAM,CAAN,CAAV;AACA,UAAI,iBAAiB,GAAjB,yCAAiB,GAAjB,CAAJ;AACA,UAAK,YAAY,IAAZ,KAAsB,YAAY,QAAZ,IAAwB,YAAY,UAA1D,CAAL,EAA8E;AAC5E,qBAAa,IAAb,CAAmB,CAAnB;AACD,OAFD,MAEO;AACL,aAAK,IAAL,CAAW,YAAY,QAAZ,GAAuB,MAAM,GAAN,GAAY,GAAnC,GAAyC,KAAK,GAAzD;AACA,kBAAU,IAAV,CAAgB,CAAhB;AACD;AACF;;AAED,QAAK,aAAa,MAAb,KAAwB,CAA7B,EAAiC;AAC/B,YAAM,IAAI,KAAJ,CAAU,iDAAV,CAAN;AACD;;AAED,SAAK,IAAL,CAAU,MAAM,aAAa,MAAb,CAAqB,SAArB,EAAiC,IAAjC,EAAN,GAAgD,GAA1D;;AAEA,SAAK,UAAL,GAAkB,KAAlB;AACA,SAAK,SAAL,GAAiB;AACf,gCADe;AAEf;AACA;AACA,gBAAU,KAAK,IAAL,CAAU,cAAV;AAJK,KAAjB;;AAOA,WAAO,KAAK,SAAZ;AACD,GA7CuB;;AA+CxB,OAAK,aAAU,KAAV,EAAkB;AACrB,QAAI,OAAO,KAAK,MAAhB;AACA,QAAM,OAAO,KAAK,KAAL,CAAY,KAAZ,CAAb;AACA,QAAM,IAAI,KAAK,YAAL,CAAkB,MAA5B;;AAEA,SAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,CAApB,EAAuB,GAAvB,EAA4B;AAC1B,UAAM,MAAM,MAAM,KAAK,YAAL,CAAkB,CAAlB,CAAN,CAAZ;AACA,UAAK,KAAK,GAAL,IAAY,KAAK,GAAL,CAAS,GAAT,CAAjB,EAAiC;AAC/B,eAAO,KAAK,GAAL,CAAS,GAAT,CAAP;AACD,OAFD,MAEO;AACL,eAAO,KAAP;AACD;AACF;;AAED,WAAO,CAAE,KAAK,GAAL,IAAY,KAAd,KAAyB,KAAK,GAAL,CAAU,KAAK,QAAf,CAAhC;AACD,GA9DuB;;AAgExB,OAAK,aAAU,KAAV,EAAiB,KAAjB,EAAyB;AAC5B,QAAI,OAAO,KAAK,MAAhB;AACA,QAAM,OAAO,KAAK,KAAL,CAAY,KAAZ,CAAb;AACA,QAAM,IAAI,KAAK,YAAL,CAAkB,MAA5B;AACA,QAAI,aAAa,KAAjB;;AAEA,SAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,CAApB,EAAuB,GAAvB,EAA4B;AAC1B,UAAM,MAAM,MAAM,KAAK,YAAL,CAAkB,CAAlB,CAAN,CAAZ;AACA,UAAK,CAAC,UAAD,IAAe,KAAK,GAAL,CAAS,GAAT,CAApB,EAAoC;AAClC,eAAO,KAAK,GAAL,CAAS,GAAT,CAAP;AACD,OAFD,MAEO;AACL,qBAAa,IAAb;AACA,aAAK,GAAL,CAAU,GAAV,EAAiB,OAAS,IAAI,IAAI,CAAV,GAAgB,IAAI,OAAJ,EAAhB,GAAgC,IAAI,GAAJ,EAAxD;AACD;AACF;;AAED,SAAK,GAAL,CAAS,KAAK,QAAd,EAAwB,KAAxB;;AAEA,WAAO,IAAP;AACD,GAnFuB;;AAqFxB,OAAK,aAAU,KAAV,EAAkB;AACrB,QAAI,OAAO,KAAK,MAAhB;AACA,QAAM,OAAO,KAAK,KAAL,CAAY,KAAZ,CAAb;AACA,QAAM,IAAI,KAAK,YAAL,CAAkB,MAA5B;;AAEA,SAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,CAApB,EAAuB,GAAvB,EAA4B;AAC1B,UAAM,MAAM,MAAM,KAAK,YAAL,CAAkB,CAAlB,CAAN,CAAZ;AACA,UAAM,MAAM,KAAK,GAAL,IAAY,KAAK,GAAL,CAAS,GAAT,CAAxB;AACA,UAAK,QAAQ,SAAb,EAAyB;AACvB,eAAO,GAAP;AACD,OAFD,MAEO;AACL,eAAO,GAAP;AACD;AACF;;AAED,WAAO,KAAK,GAAL,IAAY,KAAK,GAAL,CAAU,KAAK,QAAf,CAAnB;AACD,GArGuB;;AAuGxB,SAAO,iBAAW;AAChB,SAAK,MAAL,GAAc,IAAI,OAAJ,EAAd;AACA,WAAO,KAAK,UAAZ;AACA,WAAO,KAAK,SAAZ;AACD;AA3GuB,CAA1B;;kBA8Ge,a","file":"index.js","sourcesContent":["// generate a random hash delimiter to avoid malicious hash collisions\nfunction MixedTupleMap() {\n  this.clear();\n}\n\nMixedTupleMap.prototype = {\n  toString: function() {\n    return '[object MixedTupleMap]';\n  },\n  // The difference between MixedTupleMap and WeakTupleMap is that this one has\n  // a hash method that sorts key parts by putting non-primitive parts first.\n  // This enables optimal garbage collection of values in the map.\n  _hash: function( tuple ) {\n    // Speed up hash generation for the folowing pattern:\n    // if ( !cache.has(t) ) { cache.set( t, slowFn(t) ); }\n    if ( tuple === this._lastTuple ) {\n      return this._lastHash;\n    }\n\n    let l = tuple.length;\n    let prim = [];\n    let primOrder = [];\n    let nonPrimOrder = [];\n\n    for( let i = 0; i < l; i++) {\n      let arg = tuple[i];\n      let argType = typeof arg;\n      if ( argType !== null && ( argType === 'object' || argType === 'function' ) ) {\n        nonPrimOrder.push( i );\n      } else {\n        prim.push( argType === 'string' ? '\"' + arg + '\"' : '' + arg );\n        primOrder.push( i );\n      }\n    }\n\n    if ( nonPrimOrder.length === 0 ) {\n      throw new Error('Tuple must have at least one non-primitive part');\n    }\n\n    prim.push('[' + nonPrimOrder.concat( primOrder ).join() + ']');\n\n    this._lastTuple = tuple;\n    this._lastHash = {\n      nonPrimOrder,\n      // concatenate serialized arguments using a complex separator\n      // (to avoid key collisions)\n      primHash: prim.join('/<[MI_SEP]>/')\n    };\n\n    return this._lastHash;\n  },\n\n  has: function( tuple ) {\n    let curr = this._cache;\n    const hash = this._hash( tuple );\n    const l = hash.nonPrimOrder.length;\n\n    for( let i = 0; i < l; i++) {\n      const arg = tuple[hash.nonPrimOrder[i]]\n      if ( curr.has && curr.has(arg) ) {\n        curr = curr.get(arg);\n      } else {\n        return false;\n      }\n    }\n\n    return ( curr.has || false ) && curr.has( hash.primHash );\n  },\n\n  set: function( tuple, value ) {\n    let curr = this._cache;\n    const hash = this._hash( tuple );\n    const l = hash.nonPrimOrder.length;\n    let mustCreate = false;\n\n    for( let i = 0; i < l; i++) {\n      const arg = tuple[hash.nonPrimOrder[i]]\n      if ( !mustCreate && curr.has(arg) ) {\n        curr = curr.get(arg);\n      } else {\n        mustCreate = true;\n        curr.set( arg, ( curr = ( i < l - 1 ) ? new WeakMap() : new Map() ) );\n      }\n    }\n\n    curr.set(hash.primHash, value);\n\n    return this;\n  },\n\n  get: function( tuple ) {\n    let curr = this._cache;\n    const hash = this._hash( tuple );\n    const l = hash.nonPrimOrder.length;\n\n    for( let i = 0; i < l; i++) {\n      const arg = tuple[hash.nonPrimOrder[i]]\n      const ret = curr.get && curr.get(arg);\n      if ( ret === undefined ) {\n        return ret;\n      } else {\n        curr = ret;\n      }\n    }\n\n    return curr.get && curr.get( hash.primHash );\n  },\n\n  clear: function() {\n    this._cache = new WeakMap();\n    delete this._lastTuple;\n    delete this._lastHash;\n  },\n};\n\nexport default MixedTupleMap;\n"]}