<!DOCTYPE html>
<html>
  <head>
    <title>StickJS</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link type="text/css" rel="stylesheet" href="assets/style.css" />
    <link type="text/css" rel="stylesheet" href="assets/pilcrow.css" />
    <link type="text/css" rel="stylesheet" href="assets/hljs-github.min.css"/>
  </head>
<body><h1 id="stickjs"><a class="header-link" href="#stickjs"></a>StickJS</h1>
<h3 id="intro"><a class="header-link" href="#intro"></a>Intro</h3>
<p>StickJS is a library for functional programming in JavaScript. It is
intended to be used in conjunction with the pipe operator <code>|&gt;</code>, which is 
currently in the proposal stage (xxx link); or better yet, the bitwise-or 
(&#39;stick&#39;) operator <code>|</code>. This way you can start using it today in your 
projects using @xxx&#39;s babel-operator-overload, and the stick is more 
enjoyable to work with to boot. </p>
<p>In addition to being fast and practical, it also introduces a new range of 
idioms and some conventions of its own. These may take some time to master, 
though people coming from a Lisp or Haskell background should hit the ground 
running. I hope to show you that it can improve both the quality of your 
code and your own enjoyment, and maybe clue you in to a new way to think 
about the whole business.</p>
<h3 id="common-patterns"><a class="header-link" href="#common-patterns"></a>Common patterns</h3>
<p>rewriting
refactoring</p>
<h1 id="github"><a class="header-link" href="#github"></a>Github</h1>
<h3 id="usage"><a class="header-link" href="#usage"></a>Usage</h3>
<h4 id="node"><a class="header-link" href="#node"></a>node</h4>
<pre class="hljs"><code>npm i stick-js <span class="hljs-comment"># or yarn</span>

cat &gt;.babelrc &lt;&lt;EOT
{<span class="hljs-string">"presets"</span>: [<span class="hljs-string">"babel-preset-es2015"</span>, <span class="hljs-string">"stage-0"</span>], <span class="hljs-string">"plugins"</span>: [
    <span class="hljs-string">"babel-plugin-operator-overload"</span>
]}
EOT

babel -d <span class="hljs-class"><span class="hljs-keyword">lib</span> <span class="hljs-title">src</span></span>
node <span class="hljs-class"><span class="hljs-keyword">lib</span>/&lt;<span class="hljs-title">entry</span>-<span class="hljs-title">file</span>&gt;.<span class="hljs-title">js</span></span></code></pre><h4 id="webpack"><a class="header-link" href="#webpack"></a>webpack</h4>
<h5 id="webpack-config:"><a class="header-link" href="#webpack-config:"></a>webpack config:</h5>
<pre class="hljs"><code><span class="hljs-attr">module:</span> {
<span class="hljs-attr">  rules:</span> [
    {
<span class="hljs-attr">      test:</span> /\.js$/,
<span class="hljs-attr">      exclude:</span> /node_modules/,
<span class="hljs-attr">      use:</span> {
<span class="hljs-attr">        loader:</span> <span class="hljs-string">'babel-loader'</span>,
<span class="hljs-attr">        options:</span> {
<span class="hljs-attr">          presets:</span> [[
            <span class="hljs-string">"env"</span>,
            { <span class="hljs-string">"modules"</span>: <span class="hljs-literal">false</span> },
          ]],
<span class="hljs-attr">          plugins:</span> [
            <span class="hljs-string">'operator-overload'</span>,
          ]
        }
      },
    },
    ...
  ]
  ...
  }</code></pre><h3 id="features"><a class="header-link" href="#features"></a>Features</h3>
<pre class="hljs"><code>;

    lodash flow near the top
    people who already <span class="hljs-keyword">use</span> lodash flow
    <span class="hljs-keyword">static</span> tools</code></pre><h3 id="synopsis:-major-features."><a class="header-link" href="#synopsis:-major-features."></a>Synopsis: major features.</h3>
<h4 id="basic-example"><a class="header-link" href="#basic-example"></a>basic example</h4>
<pre class="hljs"><code><span class="hljs-regexp">//</span> --- source files must begin with <span class="hljs-keyword">this</span> header.
defineBinaryOperator (<span class="hljs-string">'|'</span>,  <span class="hljs-function"><span class="hljs-params">(...args)</span> =&gt;</span> pipe         (...args))
defineBinaryOperator (<span class="hljs-string">'&lt;&lt;'</span>, <span class="hljs-function"><span class="hljs-params">(...args)</span> =&gt;</span> compose      (...args))
defineBinaryOperator (<span class="hljs-string">'&gt;&gt;'</span>, <span class="hljs-function"><span class="hljs-params">(...args)</span> =&gt;</span> composeRight (...args))
<span class="hljs-regexp">//</span> --- /header

<span class="hljs-keyword">import</span> {
    pipe, compose, composeRight,
    map, join,
} <span class="hljs-keyword">from</span> <span class="hljs-string">'stick'</span>

const { log, } = <span class="hljs-built_in">console</span>

; [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
| map (x =&gt; x + <span class="hljs-number">1</span>)
| join (<span class="hljs-string">'/'</span>)
| sprintf1 (<span class="hljs-string">'The answer is %s'</span>)
| log <span class="hljs-regexp">//</span> outputs <span class="hljs-string">'The answer is 2/3/4'</span></code></pre><h4 id="the-'stick'-operator"><a class="header-link" href="#the-'stick'-operator"></a>the &#39;stick&#39; operator</h4>
<pre class="hljs"><code>defineBinaryOperator (<span class="hljs-string">'|'</span>,  (...args) =&gt; pipe         (...args))
defineBinaryOperator (<span class="hljs-string">'&lt;&lt;'</span>, (...args) =&gt; compose      (...args))
defineBinaryOperator (<span class="hljs-string">'&gt;&gt;'</span>, (...args) =&gt; composeRight (...args))

<span class="hljs-keyword">import</span> {
    pipe, compose, composeRight,
    map, join, split,
} <span class="hljs-keyword">from</span> <span class="hljs-string">'stick'</span>

<span class="hljs-comment">// --- `a | b` is simply an equivalent way of writing `b (a)`</span>
<span class="hljs-keyword">const</span> double = <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x * <span class="hljs-number">2</span>

<span class="hljs-number">3</span> | double <span class="hljs-comment">// 6</span>
double (<span class="hljs-number">3</span>) <span class="hljs-comment">// 6</span>

<span class="hljs-comment">// ------ what if I really want to do bitwise math?</span>
<span class="hljs-comment">// --- 1) use the functional form</span>

<span class="hljs-keyword">import</span> { bitwiseOr, bitwiseShiftBy, } <span class="hljs-keyword">from</span> <span class="hljs-string">'stick'</span>
<span class="hljs-number">4</span> | bitwiseOr (<span class="hljs-number">9</span>) <span class="hljs-comment">// 13</span>

<span class="hljs-comment">// --- or 2) do your bitwise math in a separate source file and omit the</span>
<span class="hljs-string">`defineBinaryOperator`</span> headers.
<span class="hljs-comment">// ------</span>

<span class="hljs-comment">// --- it becomes interesting when `b` is curried.</span>
<span class="hljs-comment">// --- this would be a good time to read XXX if you're not familiar with curried functions.</span>

<span class="hljs-keyword">const</span> multiply = <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> y =&gt; x * y

<span class="hljs-keyword">const</span> b = multiply (<span class="hljs-number">4</span>) <span class="hljs-comment">// b is a function</span>

<span class="hljs-number">3</span> | b            <span class="hljs-comment">// 12</span>
<span class="hljs-number">3</span> | multiply (<span class="hljs-number">4</span>) <span class="hljs-comment">// 12</span>

<span class="hljs-keyword">const</span> triple = <span class="hljs-number">3</span> | multiply
<span class="hljs-number">4</span> | triple       <span class="hljs-comment">// 12</span>

<span class="hljs-keyword">const</span> capitaliseFirstLetter = <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x[<span class="hljs-number">0</span>].toUpperCase () + x.slice (<span class="hljs-number">1</span>)

<span class="hljs-string">'just a perfect day'</span>
| split (<span class="hljs-string">' '</span>)                 <span class="hljs-comment">// split (' ') is a function</span>
| map (capitaliseFirstLetter) <span class="hljs-comment">// map (capitaliseFirstLetter) is a function</span>
| join (<span class="hljs-string">' '</span>)                  <span class="hljs-comment">// join (' ') is a function</span>
<span class="hljs-comment">// 'Just A Perfect Day'</span>

<span class="hljs-comment">// --- 2 currying styles: we will refer to this sort of function as 'manually curried'</span>
<span class="hljs-keyword">const</span> f = <span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> b =&gt; <span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> a + b + c <span class="hljs-comment">// call like f (1) (2) (3)</span>
<span class="hljs-comment">// --- and this sort as 'normally curried'</span>
<span class="hljs-keyword">const</span> g = R.curry (<span class="hljs-function">(<span class="hljs-params">a, b, c</span>) =&gt;</span> a + b + c) <span class="hljs-comment">// call like f (1) (2) (3) or f (1, 2, 3)</span>

<span class="hljs-comment">// --- all curried functions provided by stick can be called using either of the styles.</span>
<span class="hljs-comment">// --- furthermore, our implementation is far faster than Ramda's (try it yourself and see)</span>
<span class="hljs-comment">// XXX</span>
<span class="hljs-comment">// --- performance, own section ...</span></code></pre><h4 id="markers"><a class="header-link" href="#markers"></a>markers</h4>
<pre class="hljs"><code>defineBinaryOperator (<span class="hljs-string">'|'</span>,  <span class="hljs-function"><span class="hljs-params">(...args)</span> =&gt;</span> pipe         (...args))
defineBinaryOperator (<span class="hljs-string">'&lt;&lt;'</span>, <span class="hljs-function"><span class="hljs-params">(...args)</span> =&gt;</span> compose      (...args))
defineBinaryOperator (<span class="hljs-string">'&gt;&gt;'</span>, <span class="hljs-function"><span class="hljs-params">(...args)</span> =&gt;</span> composeRight (...args))

<span class="hljs-keyword">import</span> {
  pipe, compose, composeRight,
  sprintfN, sprintf1,
} <span class="hljs-keyword">from</span> <span class="hljs-string">'stick'</span>

<span class="hljs-number">3</span> | sprintf1 (<span class="hljs-string">'4 - 1 is %s'</span>) <span class="hljs-regexp">//</span> <span class="hljs-string">'4 - 1 is 3'</span>

; [<span class="hljs-number">4</span>, <span class="hljs-number">3</span>]
| sprintfN (<span class="hljs-string">'%s - 1 is %s'</span>) <span class="hljs-regexp">//</span> same. <span class="hljs-string">'N'</span> <span class="hljs-keyword">is</span> a marker meaning an array <span class="hljs-keyword">is</span> expected.</code></pre><h4 id="ok,-anaphoric-if"><a class="header-link" href="#ok,-anaphoric-if"></a>ok, anaphoric if</h4>
<pre class="hljs"><code>defineBinaryOperator (<span class="hljs-string">'|'</span>,  <span class="hljs-function"><span class="hljs-params">(...args)</span> =&gt;</span> pipe         (...args))
defineBinaryOperator (<span class="hljs-string">'&lt;&lt;'</span>, <span class="hljs-function"><span class="hljs-params">(...args)</span> =&gt;</span> compose      (...args))
defineBinaryOperator (<span class="hljs-string">'&gt;&gt;'</span>, <span class="hljs-function"><span class="hljs-params">(...args)</span> =&gt;</span> composeRight (...args))

<span class="hljs-keyword">import</span> {
  pipe, compose, composeRight,
  map, ok, notOk,
  ifOk,
} <span class="hljs-keyword">from</span> <span class="hljs-string">'stick'</span>

const { log, } = <span class="hljs-built_in">console</span>

const someVar = ...
someVar | ok <span class="hljs-regexp">//</span> <span class="hljs-literal">true</span> <span class="hljs-keyword">if</span> `<span class="javascript">someVar</span>` <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> `<span class="javascript"><span class="hljs-literal">null</span></span>` <span class="hljs-keyword">or</span> `<span class="javascript"><span class="hljs-literal">undefined</span></span>`

; [<span class="hljs-number">0</span>, <span class="hljs-literal">false</span>, <span class="hljs-string">''</span>, <span class="hljs-literal">null</span>, void <span class="hljs-number">8</span>]
| map (ok)    <span class="hljs-regexp">//</span> [<span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>]

; [<span class="hljs-number">0</span>, <span class="hljs-literal">false</span>, <span class="hljs-string">''</span>, <span class="hljs-literal">null</span>, void <span class="hljs-number">8</span>]
| map (notOk) <span class="hljs-regexp">//</span> [<span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>]

<span class="hljs-regexp">//</span> --- we see <span class="hljs-keyword">this</span> a lot <span class="hljs-keyword">in</span> JS:

let answer
<span class="hljs-keyword">if</span> (someVar !== <span class="hljs-literal">undefined</span> &amp;&amp; someVar !== <span class="hljs-literal">null</span>) {
  answer = someVar + <span class="hljs-number">1</span>
} <span class="hljs-keyword">else</span> {
  answer = <span class="hljs-string">'nothing'</span>
}

<span class="hljs-regexp">//</span> --- it can be vastly improved using an <span class="hljs-string">'anaphoric if'</span> <span class="hljs-keyword">and</span> a stick idiom:

const add1IfYouCan = val =&gt; val
  | ifOk (
    <span class="hljs-regexp">//</span> <span class="hljs-keyword">in</span> the <span class="hljs-string">'ok'</span> case, the value <span class="hljs-keyword">is</span> passed to the function.
    x =&gt; x + <span class="hljs-number">1</span>,
    <span class="hljs-regexp">//</span> <span class="hljs-keyword">in</span> the <span class="hljs-string">'not ok'</span> case, <span class="hljs-literal">no</span> value <span class="hljs-keyword">is</span> passed.
    _ =&gt; <span class="hljs-string">'nothing'</span>,
  )

<span class="hljs-regexp">//</span> --- <span class="hljs-keyword">or</span> a variant:

<span class="hljs-keyword">import</span> { add, always, } <span class="hljs-keyword">from</span> <span class="hljs-string">'stick'</span>

const add1 = <span class="hljs-number">1</span> | add <span class="hljs-regexp">//</span> <span class="hljs-keyword">or</span> add (<span class="hljs-number">1</span>)
const add1IfYouCan = x =&gt; x | ifOk (add1, <span class="hljs-string">'nothing'</span> | always)

<span class="hljs-regexp">//</span> --- usage:

; [<span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-literal">null</span>, void <span class="hljs-number">8</span>]
| map (add1IfYouCan) <span class="hljs-regexp">//</span> [<span class="hljs-number">1</span>, <span class="hljs-number">11</span>, <span class="hljs-string">'nothing'</span>, <span class="hljs-string">'nothing'</span>]</code></pre><h4 id="point-free"><a class="header-link" href="#point-free"></a>point-free</h4>
<p>// --- a common pattern is when the argument to a function is passed directly into a pipe:</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> add1IfYouCan = <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x | ifOk (add1, <span class="hljs-string">'nothing'</span> | always)</code></pre><p>// --- since <code>x</code> does not appear anywhere else, we can simply remove it:</p>
<pre class="hljs"><code>const add1IfYouCan = ifOk (<span class="hljs-name">add1</span>, 'nothing' | always)</code></pre><p>// --- if the pipe chain consists of more than 1 link:</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> { log, } = <span class="hljs-built_in">console</span>
<span class="hljs-keyword">const</span> add1IfYouCan = <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x
  | ifOk (add1, <span class="hljs-string">'nothing'</span> | always)
  | <span class="hljs-built_in">String</span>                          <span class="hljs-comment">// type conversions are easy using type constructors by the way</span>
  | dot (<span class="hljs-string">'toUpperCase'</span>)
  | sprintf1 (<span class="hljs-string">'The answer is %s'</span>)
  | tap (log)                     <span class="hljs-comment">// outputs 'The answer is 1' or 'The answer is NOTHING' or ...</span></code></pre><p>// --- ... then we remove the <code>x =&gt; x</code> and change all the <code>|</code> to <code>&gt;&gt;</code></p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> { <span class="hljs-built_in">log</span>, } = console
<span class="hljs-keyword">const</span> { dot, sprintf1, tap, }
<span class="hljs-keyword">const</span> add1IfYouCan =
  ifOk (add1, <span class="hljs-string">'nothing'</span> | always)
  &gt;&gt; <span class="hljs-built_in">String</span>
  &gt;&gt; dot (<span class="hljs-string">'toUpperCase'</span>)
  &gt;&gt; sprintf1 (<span class="hljs-string">'The answer is %s'</span>)
  &gt;&gt; tap (<span class="hljs-built_in">log</span>)</code></pre><h4 id="compositional-predicates"><a class="header-link" href="#compositional-predicates"></a>compositional predicates</h4>
<h5 id="(from-here-on-out-we-omit-the-header,-but-do-not-forget-it-...)"><a class="header-link" href="#(from-here-on-out-we-omit-the-header,-but-do-not-forget-it-...)"></a>(from here on out we omit the header, but do not forget it ...)</h5>
<p>  // --- <code>ifOk</code> is a convenience for <code>ifPredicate (ok)</code> or <code>ok | ifPredicate</code>
  // --- there is also a &#39;when&#39; form, which has no &#39;else branch&#39;.</p>
<pre class="hljs"><code>  import { <span class="hljs-keyword">add</span>, whenOk, } <span class="hljs-keyword">from</span> <span class="hljs-string">'stick'</span>
  <span class="hljs-keyword">const</span> add1 = <span class="hljs-number">1</span> | <span class="hljs-keyword">add</span> <span class="hljs-comment">// or add (1)</span>
  <span class="hljs-number">3</span>    | whenOk (add1) <span class="hljs-comment">// 4</span>
  <span class="hljs-literal">null</span> | whenOk (add1) <span class="hljs-comment">// undefined</span></code></pre><p>  // --- the selection of <code>if</code> and <code>when</code> functions we provide is intentionally skimpy, to encourage you to write your own.</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> { <span class="hljs-built_in">floor</span>, } = Math
<span class="hljs-keyword">const</span> isInteger = x =&gt; x === <span class="hljs-built_in">floor</span> (x)

<span class="hljs-comment">// --- or how about</span>
<span class="hljs-comment">// const isInteger = x =&gt; x | floor | eq (x)</span>

<span class="hljs-comment">// --- or if you're getting bored:</span>
<span class="hljs-comment">// const arrowSnd = f =&gt; timesV (2) &gt;&gt; asterisk ([id, f])</span>
<span class="hljs-comment">// const isInteger = arrowSnd (floor) &gt;&gt; passToN (eq)</span>

<span class="hljs-comment">// --- now compose it into an anaphoric if:</span>

<span class="hljs-keyword">const</span> ifInteger = isInteger | ifPredicate

<span class="hljs-keyword">const</span> add1 = <span class="hljs-built_in">add</span> (<span class="hljs-number">1</span>)

; [<span class="hljs-number">3.5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4.2</span>]
| <span class="hljs-built_in">map</span> (ifInteger (add1, <span class="hljs-string">'nothing'</span> | always))
  <span class="hljs-comment">// ['nothing', 5, 'nothing']</span></code></pre><p>  // --- more complicated predicates</p>
<p>  // --- @todo remove
  const both = (f, g) =&gt; x =&gt; f (x) &amp;&amp; g (x) ? true : false</p>
<p>  const isOdd = x =&gt; x % 2</p>
<p>  const isOddInteger = both (isInteger, isOdd)
  const ifOddInteger = isOddInteger | ifPredicate</p>
<p>  ; [3.5, 4, 5, 5.5]
  | map (ifOddInteger (
    add1,
    &#39;nothing&#39; | always,
  ))
  | log</p>
<p>  ; [3.5, 4, 5, 5.5] | map (isOddInteger) | log</p>
<h4 id="compositional-decoration"><a class="header-link" href="#compositional-decoration"></a>compositional decoration</h4>
<pre class="hljs"><code>defineBinaryOperator (<span class="hljs-string">'|'</span>,  <span class="hljs-function"><span class="hljs-params">(...args)</span> =&gt;</span> pipe         (...args))
defineBinaryOperator (<span class="hljs-string">'&lt;&lt;'</span>, <span class="hljs-function"><span class="hljs-params">(...args)</span> =&gt;</span> compose      (...args))
defineBinaryOperator (<span class="hljs-string">'&gt;&gt;'</span>, <span class="hljs-function"><span class="hljs-params">(...args)</span> =&gt;</span> composeRight (...args))

<span class="hljs-keyword">import</span> {
  pipe, compose, composeRight,
  map,
  addIndex, addCollection,
} <span class="hljs-keyword">from</span> <span class="hljs-string">'stick'</span>

; [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]
| map (<span class="hljs-function"><span class="hljs-params">(x, idx)</span> =&gt;</span> idx) <span class="hljs-regexp">//</span> [<span class="hljs-literal">undefined</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-literal">undefined</span>]

const mapWithIndex = map | addIndex
; [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]
| mapWithIndex (<span class="hljs-function"><span class="hljs-params">(x, idx)</span> =&gt;</span> idx) <span class="hljs-regexp">//</span> [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]

const mapWithCollection = map | addCollection
; [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]
| mapWithCollection (<span class="hljs-function"><span class="hljs-params">(x, coll)</span> =&gt;</span> coll) <span class="hljs-regexp">//</span> [[<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]]

; [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]
  | (map | addIndex | addCollection) (<span class="hljs-function"><span class="hljs-params">(x, idx, coll)</span> =&gt;</span> ...)

; [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]
  | (map | addCollection | addIndex) (<span class="hljs-function"><span class="hljs-params">(x, coll, idx)</span> =&gt;</span> ...)</code></pre><h4 id="semantics-and-argument-order-are-often-derivable-by-thinking-in-english"><a class="header-link" href="#semantics-and-argument-order-are-often-derivable-by-thinking-in-english"></a>semantics and argument order are often derivable by thinking in English</h4>
<pre class="hljs"><code>defineBinaryOperator ('|',  (...args) =&gt; pipe         (...args))
defineBinaryOperator ('&lt;&lt;', (...args) =&gt; compose      (...args))
defineBinaryOperator ('&gt;&gt;', (...args) =&gt; composeRight (...args))

import {
  pipe, compose, composeRight,
  sprintfN, sprintf1, mergeTo, merge, prependTo, prepend,
  appendTo, append, bindPropTo, bindProp, bindTo, bind, invoke,
} from 'stick'
<span class="hljs-built_in">
const </span>obj1 = { thing: 'sandwich', want: 'no thanks', }<span class="hljs-built_in">
const </span>obj2 = { want: 'yes please', }

// --- obj1 is the object of the preposition 'to'. Read as: 'merge obj2 to obj1'
obj2 | mergeTo (obj1)
// --- No preposition -&gt; obj1 is the object of the verb 'merge'.
// --- Read as: 'merge obj2 to obj1'
obj1 | merge (obj2)

4 | appendTo ([1, 2, 3])
; ([1, 2, 3]) | append (4)

0 | prependTo ([1, 2, 3])
; ([1, 2, 3]) | prepend (0)
<span class="hljs-built_in">
const </span>dog = {
  name: 'Caesar',
  speak () {<span class="hljs-built_in"> return </span>'My name is ' + this.name },
}
<span class="hljs-built_in">
const </span>cat = {
  name: 'Bo',
  speak () {<span class="hljs-built_in"> throw </span>new Error },
}
<span class="hljs-built_in">
const </span>f = 'speak' | bindPropTo (dog)
f () // 'My name is Caesar'

'speak' | bindPropTo (dog)   |<span class="hljs-built_in"> invoke </span>// same
dog     | bindProp ('speak') |<span class="hljs-built_in"> invoke </span>// same

dog.speak | bindTo (dog) |<span class="hljs-built_in"> invoke </span>// smae

// cat.speak () // Error
dog.speak | bindTo (cat) |<span class="hljs-built_in"> invoke </span>// 'My name is Bo'
cat | bind (dog.speak)   |<span class="hljs-built_in"> invoke </span>// 'My name is Bo'</code></pre><h4 id="side-effects-&-chaining,-mutable-vs-immutable"><a class="header-link" href="#side-effects-&-chaining,-mutable-vs-immutable"></a>side effects &amp; chaining, mutable vs immutable</h4>
<p>defineBinaryOperator (&#39;|&#39;,  (...args) =&gt; pipe         (...args))
defineBinaryOperator (&#39;&lt;&lt;&#39;, (...args) =&gt; compose      (...args))
defineBinaryOperator (&#39;&gt;&gt;&#39;, (...args) =&gt; composeRight (...args))</p>
<p>import {
  pipe, compose, composeRight,
  map, side1, appendM, append, prependM, prepend,
} from &#39;stick&#39;</p>
<p>// --- chaining with the . will often not do what you want.</p>
<p>; [2, 3, 4]
  .push (5)
  .unshift (1) // error, return value of previous line was 5</p>
<p>// --- this will:</p>
<p>const push    = &#39;push&#39; | side1
const unshift = &#39;unshift&#39; | side1</p>
<p>; [2, 3, 4]
| push (5)
| unshift (1) // [1, 2, 3, 4, 5]</p>
<p>// --- using stick functions for mutable data:</p>
<p>; [2, 3, 4]
| appendM (5)
| prependM (1)</p>
<p>// --- using stick functions for immutable data:</p>
<p>; [2, 3, 4]
| append (5)  // new array [2, 3, 4, 5]
| prepend (1) // new array [1, 2, 3, 4, 5]</p>
<h4 id="dog"><a class="header-link" href="#dog"></a>dog</h4>
<h4 id="this-example-is-intentionally-complex"><a class="header-link" href="#this-example-is-intentionally-complex"></a>this example is intentionally complex</h4>
<p><img src="https://placehold.it/15/f03c15/000000?text=hello" alt="#f03c15"> <code>#f03c15</code></p>
<pre class="hljs"><code>yarn <span class="hljs-built_in">add</span> ramda chalk

---

defineBinaryOperator (<span class="hljs-string">'|'</span>,  (...args) =&gt; pipe         (...args))
defineBinaryOperator (<span class="hljs-string">'&lt;&lt;'</span>, (...args) =&gt; compose      (...args))
defineBinaryOperator (<span class="hljs-string">'&gt;&gt;'</span>, (...args) =&gt; composeRight (...args))

<span class="hljs-keyword">import</span> {
  pipe, compose, composeRight,
  recurry, <span class="hljs-built_in">map</span>, <span class="hljs-built_in">join</span>, condS, guard, otherwise,
  sprintfN, rangeTo, lt, gt,
  tap, appendTo, prop,
} from <span class="hljs-string">'stick'</span>

<span class="hljs-keyword">import</span> {
  curry,
} from <span class="hljs-string">'ramda'</span>

<span class="hljs-keyword">import</span> {
  yellow, <span class="hljs-built_in">green</span>, <span class="hljs-built_in">red</span>,
} from <span class="hljs-string">'chalk'</span>

<span class="hljs-keyword">const</span> { <span class="hljs-built_in">log</span>, } = console

<span class="hljs-keyword">const</span> cmpStr = curry ((<span class="hljs-built_in">str</span>, <span class="hljs-built_in">color</span>, tgtStr, x) =&gt; [x, <span class="hljs-built_in">str</span> | <span class="hljs-built_in">color</span>, tgtStr]
  | sprintfN (<span class="hljs-string">'%s is %s %s'</span>)
)

<span class="hljs-keyword">const</span> lessThanStr     = cmpStr (<span class="hljs-string">'less than'</span>, yellow)
<span class="hljs-keyword">const</span> greaterThanStr  = cmpStr (<span class="hljs-string">'greater than'</span>, <span class="hljs-built_in">red</span>)
<span class="hljs-keyword">const</span> inBetweenString = ([ low, high ]) =&gt; cmpStr (<span class="hljs-string">'in between'</span>, <span class="hljs-built_in">green</span>, [low, high] | <span class="hljs-built_in">join</span> (<span class="hljs-string">' and '</span>))

<span class="hljs-keyword">const</span> getCmpStr = curry ((low, high, x) =&gt; x
  | condS ([
    low | lt | guard ((low | lessThanStr) &gt;&gt; appendTo ([<span class="hljs-number">-1</span>])),
    high | gt | guard ((high | greaterThanStr) &gt;&gt; appendTo ([<span class="hljs-number">1</span>])),
    otherwise | guard (inBetweenString ([low, high]) &gt;&gt; appendTo ([<span class="hljs-number">0</span>])),
  ])
)

<span class="hljs-keyword">const</span> inRange = ([low, high]) =&gt; x =&gt; getCmpStr (low, high, x)

<span class="hljs-keyword">const</span> snd = prop (<span class="hljs-number">1</span>)
<span class="hljs-keyword">const</span> fst = prop (<span class="hljs-number">0</span>)

<span class="hljs-number">10</span> | rangeTo (<span class="hljs-number">20</span>)             <span class="hljs-comment">// [10, 11, ... 19]</span>
   | <span class="hljs-built_in">map</span> (inRange ([<span class="hljs-number">13</span>, <span class="hljs-number">17</span>])) <span class="hljs-comment">// maps to tuples of [int, str]</span>
   | tap (<span class="hljs-built_in">map</span> (snd &gt;&gt; <span class="hljs-built_in">log</span>))   <span class="hljs-comment">// logs the str</span>
   | <span class="hljs-built_in">map</span> (fst)                <span class="hljs-comment">// [-1, -1, ... 0, ... 1, 1]</span></code></pre><h3 id="performance"><a class="header-link" href="#performance"></a>performance</h3>
<p>Stick is fast. See here for a benchmark of our factory example.</p>
<p>Stick is much faster than Ramda. Though it initially depended on
Ramda, we have decided to eliminate that dependency by reimplementing many
of the functions. While profiling the WebGL example we found that even
trivial functions like <code>R.flip</code> and <code>R.tap</code> are surprisingly expensive.</p>
<p>This really only becomes an issue in tight loops -- an inner loop of a
socket or server, an animation, a particle system where lots of objects are
spawned per second, WebGL. For cases like these, see below.</p>
<p>It is true that <code>a | b</code> compiles to three function calls, whereas <code>b (a)</code> is
only one. But this is almost certainly not going to affect your app. Your JS
runtime can call <em>a lot</em> of functions per millisecond.</p>
<p>Nonetheless you are encouraged to mix and match our functions with whichever
functional libraries you like -- Ramda, Lodash/FP, or anything else, as it
suits you.</p>
<pre class="hljs"><code><span class="hljs-keyword">import</span> { map, } <span class="hljs-keyword">from</span> <span class="hljs-string">'ramda'</span>
<span class="hljs-keyword">import</span> { filter, } <span class="hljs-keyword">from</span> <span class="hljs-string">'lodash/fp'</span>
<span class="hljs-keyword">import</span> { ifPredicate, } <span class="hljs-keyword">from</span> <span class="hljs-string">'stick'</span></code></pre><p>The stick idiom will still work, as long as the functions are curried and
data-last.</p>
<p>Furthermore Ramda is probably perfectly fine for your app, and its functions
often provide type-checking and error messages (we don&#39;t), and many of their
functions are more sophisticated. <code>R.map</code> works on functors and
transformers, for example -- ours doesn&#39;t.</p>
<p>And, it is our belief that if you are already using the <code>flow</code> pattern in
Lodash/FP or the <code>pipe</code> function in Ramda, that it will really be a
no-brainer to overload the operator and keep everything else the same.</p>
<pre class="hljs"><code><span class="hljs-symbol">_</span>.flow (
  <span class="hljs-symbol">_</span>.<span class="hljs-built_in">split</span> (' '),
  <span class="hljs-symbol">_</span>.<span class="hljs-built_in">map</span> (capitaliseFirstLetter),
  <span class="hljs-symbol">_</span>.<span class="hljs-built_in">join</span> (' '),
) (myData)

// -&gt;
myData
| <span class="hljs-symbol">_</span>.<span class="hljs-built_in">split</span> (' '),
| <span class="hljs-symbol">_</span>.<span class="hljs-built_in">map</span> (capitaliseFirstLetter),
| <span class="hljs-symbol">_</span>.<span class="hljs-built_in">join</span> (' ')</code></pre><p>merge benchmark: manual / index / ramda</p>
<h3 id="extra-performance"><a class="header-link" href="#extra-performance"></a>Extra performance</h3>
<p>For speed freaks: check the docs to see if your function is exported by
&#39;stick/manual&#39;. If so, you can directly import the manual version, but you
must remember to call it using the manual style:</p>
<pre class="hljs"><code>import { merge, } from <span class="hljs-string">'stick/manual'</span>
merge <span class="hljs-comment">(obj1, obj2)</span> <span class="hljs-comment">// will not work</span>
obj<span class="hljs-number">2</span> | merge <span class="hljs-comment">(obj1)</span> <span class="hljs-comment">// ok</span>
merge <span class="hljs-comment">(obj1)</span> <span class="hljs-comment">(obj2)</span> <span class="hljs-comment">// also ok</span></code></pre></body>
</html>
