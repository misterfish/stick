<!DOCTYPE html>
<html>
  <head>
    <title>Usage</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link type="text/css" rel="stylesheet" href="assets/style.css" />
    <link type="text/css" rel="stylesheet" href="assets/pilcrow.css" />
    <link type="text/css" rel="stylesheet" href="assets/hljs-github.min.css"/>
  </head>
<body><h1 id="usage"><a class="header-link" href="#usage"></a>Usage</h1>
<h2 id="٭-node"><a class="header-link" href="#٭-node"></a>٭ node</h2>
<pre class="hljs"><code>npm i stick-js <span class="hljs-comment"># or yarn</span>

cat &gt;.babelrc &lt;&lt;EOT
{<span class="hljs-string">"presets"</span>: [<span class="hljs-string">"babel-preset-es2015"</span>, <span class="hljs-string">"stage-0"</span>], <span class="hljs-string">"plugins"</span>: [
    <span class="hljs-string">"babel-plugin-operator-overload"</span>
]}
EOT

node_modules/.bin/babel -d <span class="hljs-class"><span class="hljs-keyword">lib</span> <span class="hljs-title">src</span></span>
node <span class="hljs-class"><span class="hljs-keyword">lib</span>/&lt;<span class="hljs-title">entry</span>-<span class="hljs-title">file</span>&gt;.<span class="hljs-title">js</span></span></code></pre><h2 id="٭-webpack"><a class="header-link" href="#٭-webpack"></a>٭ webpack</h2>
<h3 id="webpack-config:"><a class="header-link" href="#webpack-config:"></a>webpack config:</h3>
<pre class="hljs"><code><span class="hljs-attr">module:</span> {
<span class="hljs-attr">  rules:</span> [
    {
<span class="hljs-attr">      test:</span> /\.js$/,
<span class="hljs-attr">      exclude:</span> /node_modules/,
<span class="hljs-attr">      use:</span> {
<span class="hljs-attr">      loader:</span> <span class="hljs-string">'babel-loader'</span>,
<span class="hljs-attr">      options:</span> {
<span class="hljs-attr">        presets:</span> [[
        <span class="hljs-string">"env"</span>,
        { <span class="hljs-string">"modules"</span>: <span class="hljs-literal">false</span> },
        ]],
<span class="hljs-attr">        plugins:</span> [
        <span class="hljs-string">'operator-overload'</span>,
        ]
      }
      },
    },
    ...
  ]
  ...
  }</code></pre><h1 id="what-we-provide"><a class="header-link" href="#what-we-provide"></a>What we provide</h1>
<ul class="list">
<li><p>A way to start using the pipe (or &#39;stick&#39;) operator today while 
proposal
<a href="https://github.com/tc39/proposal-pipeline-operator">TC39/proposal-pipeline-operator</a>
is still being fleshed out.</p>
<p>Note that we use <code>|</code>, not <code>|&gt;</code>, which is not only easier to overload but
far more pleasant to work with, and which will still work even if/when the
proposal is accepted.</p>
</li>
<li><p>A toolkit of functions centered around this pattern, and a number of
idioms which they facilitate.</p>
<p>You can use our functions, or your own favorite library (Ramda, lodash/fp,
etc.), or mix and match as you like.</p>
</li>
</ul>
<p>The overloading is made possible thanks to the great
<a href="https://github.com/jussi-kalliokoski/babel-plugin-operator-overload">babel-plugin-operator-overload</a>
library by Jussi Kalliokoski (@jussi-kalliokoski).</p>
<h1 id="tl;dr"><a class="header-link" href="#tl;dr"></a>TL;DR</h1>
<p>A few examples:</p>
<pre class="hljs"><code><span class="hljs-keyword">import</span> chalk from <span class="hljs-string">'chalk'</span>

; [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
| <span class="hljs-built_in">map</span> (x =&gt; x + <span class="hljs-number">1</span>)
| <span class="hljs-built_in">join</span> (<span class="hljs-string">'/'</span>)
| chalk.<span class="hljs-built_in">green</span>
| sprintf1 (<span class="hljs-string">'The answer is %s'</span>)
| <span class="hljs-built_in">log</span> <span class="hljs-comment">// outputs 'The answer is 2/3/4' (colorfully)</span></code></pre><hr>
<pre class="hljs"><code><span class="hljs-keyword">const</span> isInteger = <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x === <span class="hljs-built_in">Math</span>.floor (x)
<span class="hljs-keyword">const</span> ifInteger = isInteger | ifPredicate

; [<span class="hljs-number">3.5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4.2</span>]
| map (ifInteger (
  <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x + <span class="hljs-number">1</span>,
  always (<span class="hljs-string">'nothing'</span>),
))
<span class="hljs-comment">// ['nothing', 5, 'nothing']</span></code></pre><hr>
<pre class="hljs"><code><span class="hljs-keyword">const</span> convertFahrenheit = fah =&gt; lets (
  _ =&gt; (fah - <span class="hljs-number">32</span>) / <span class="hljs-number">9</span> * <span class="hljs-number">5</span>,    <span class="hljs-comment">// (1) celsius</span>
  (cel) =&gt; cel + <span class="hljs-number">273</span>,         <span class="hljs-comment">// (2) kelvin</span>
  (cel, kel) =&gt; [cel, kel],   <span class="hljs-comment">// (3) result</span>
)

convertFahrenheit (<span class="hljs-number">86</span>) <span class="hljs-comment">// [30, 303]</span></code></pre><hr>
<pre class="hljs"><code>const checkVal = condS ([
  <span class="hljs-number">4</span> | e<span class="hljs-string">q    | guard  (sprintf1 ('%s was exactly 4')),
  4 |</span> <span class="hljs-keyword">lt</span>    | guard  (sprintf1 (<span class="hljs-string">'%s was less than 4'</span>)),
  <span class="hljs-number">4</span> | <span class="hljs-keyword">gt</span>    | guard  (sprintf1 (<span class="hljs-string">'%s was more than 4'</span>)),
  otherwise | guardV (<span class="hljs-string">"error, this shouldn't happen"</span>),
])

; [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
| <span class="hljs-keyword">map</span> (checkVal)
| <span class="hljs-keyword">join</span> (<span class="hljs-string">' | '</span>)
// <span class="hljs-number">3</span> was less than <span class="hljs-number">4</span> | <span class="hljs-number">4</span> was exactly <span class="hljs-number">4</span> | <span class="hljs-number">5</span> was more than <span class="hljs-number">4</span></code></pre><hr>
<pre class="hljs"><code><span class="hljs-comment">// ------ dog.js</span>
<span class="hljs-keyword">const</span> proto = { speak () { <span class="hljs-string">'Hi from '</span> + <span class="hljs-keyword">this</span>.name }}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> proto | <span class="hljs-keyword">factory</span>

<span class="hljs-comment">// ------ main.js</span>
<span class="hljs-keyword">import</span> Dog from <span class="hljs-string">'./dog'</span>
Dog.create ({ name: <span class="hljs-string">'Caesar'</span>, }).speak () <span class="hljs-comment">// 'Hi from Caesar'</span></code></pre><hr>
<p>And much more.</p>
<h1 id="overview"><a class="header-link" href="#overview"></a>Overview</h1>
<h2 id="٭-basic-example-٭"><a class="header-link" href="#٭-basic-example-٭"></a>٭ basic example ٭</h2>
<pre class="hljs"><code><span class="hljs-regexp">//</span> --- source files must begin with <span class="hljs-keyword">this</span> header.

defineBinaryOperator (<span class="hljs-string">'|'</span>,  <span class="hljs-function"><span class="hljs-params">(...args)</span> =&gt;</span> pipe         (...args))
defineBinaryOperator (<span class="hljs-string">'&lt;&lt;'</span>, <span class="hljs-function"><span class="hljs-params">(...args)</span> =&gt;</span> compose      (...args))
defineBinaryOperator (<span class="hljs-string">'&gt;&gt;'</span>, <span class="hljs-function"><span class="hljs-params">(...args)</span> =&gt;</span> composeRight (...args))

<span class="hljs-keyword">import</span> {
    pipe, compose, composeRight,

<span class="hljs-regexp">//</span> --- /header

    map, join, sprintf1,
} <span class="hljs-keyword">from</span> <span class="hljs-string">'stick-js'</span>

<span class="hljs-keyword">import</span> { green, } <span class="hljs-keyword">from</span> <span class="hljs-string">'chalk'</span>

const { log, } = <span class="hljs-built_in">console</span>

; [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
| map (x =&gt; x + <span class="hljs-number">1</span>)
| join (<span class="hljs-string">'/'</span>)
| green
| sprintf1 (<span class="hljs-string">'The answer is %s'</span>)
| log <span class="hljs-regexp">//</span> outputs <span class="hljs-string">'The answer is 2/3/4'</span> (colorfully)</code></pre><h2 id="٭-the-'stick'-operator-٭"><a class="header-link" href="#٭-the-'stick'-operator-٭"></a>٭ the &#39;stick&#39; operator ٭</h2>
<p><code>a | b</code> is simply an equivalent way of writing <code>b (a)</code></p>
<p>A really simple idea, with some pretty far-reaching consequences.</p>
<p>(What if I really want to do bitwise math, you ask? Don&#39;t worry, you still
can: see below).</p>
<pre class="hljs"><code><span class="hljs-comment">// --- reminder: source files must begin with this.</span>
<span class="hljs-comment">// --- from here on out we'll omit it in the examples.</span>
defineBinaryOperator (<span class="hljs-string">'|'</span>,  (...args) =&gt; pipe         (...args))
defineBinaryOperator (<span class="hljs-string">'&lt;&lt;'</span>, (...args) =&gt; compose      (...args))
defineBinaryOperator (<span class="hljs-string">'&gt;&gt;'</span>, (...args) =&gt; composeRight (...args))

<span class="hljs-keyword">import</span> {
  pipe, compose, composeRight,
  map, join, split,
} from <span class="hljs-string">'stick-js'</span>

<span class="hljs-keyword">const</span> multiply = x =&gt; y =&gt; x * y
<span class="hljs-keyword">const</span> <span class="hljs-built_in">double</span> = multiply (<span class="hljs-number">2</span>)     <span class="hljs-comment">// or 2 | multiply</span>

<span class="hljs-number">3</span> | <span class="hljs-built_in">double</span>                      <span class="hljs-comment">// 6</span>
<span class="hljs-built_in">double</span> (<span class="hljs-number">3</span>)                      <span class="hljs-comment">// 6</span>
<span class="hljs-number">3</span> | multiply (<span class="hljs-number">4</span>)                <span class="hljs-comment">// 12</span>

<span class="hljs-keyword">const</span> capitaliseFirstLetter = x =&gt; x[<span class="hljs-number">0</span>].toUpperCase () + x.slice (<span class="hljs-number">1</span>)

<span class="hljs-string">'just a perfect day'</span>
  | split (<span class="hljs-string">' '</span>)                 <span class="hljs-comment">// split (' ') is a function</span>
  | map (capitaliseFirstLetter) <span class="hljs-comment">// map (capitaliseFirstLetter) is also a function</span>
  | join (<span class="hljs-string">' '</span>)                  <span class="hljs-comment">// ... you get the picture.</span>
<span class="hljs-comment">// 'Just A Perfect Day'</span></code></pre><h2 id="٭-currying-styles-٭"><a class="header-link" href="#٭-currying-styles-٭"></a>٭ currying styles ٭</h2>
<p>All curried functions provided by stick-js can be called using either of 2 currying styles.</p>
<p>This would be a good time to read up on curried functions if you&#39;re not familiar with them.</p>
<ol class="list">
<li><p>we will refer to this sort of function and calling style as &#39;manual&#39;:</p>
<pre class="hljs"><code> const f = <span class="hljs-selector-tag">a</span> =&gt; <span class="hljs-selector-tag">b</span> =&gt; c =&gt; <span class="hljs-selector-tag">a</span> + <span class="hljs-selector-tag">b</span> + c          <span class="hljs-comment">// call like f (1) (2) (3)</span></code></pre></li>
<li><p>and this sort as &#39;normal&#39;:</p>
<pre class="hljs"><code> const g = R<span class="hljs-selector-class">.curry</span> ((<span class="hljs-selector-tag">a</span>, <span class="hljs-selector-tag">b</span>, c) =&gt; <span class="hljs-selector-tag">a</span> + <span class="hljs-selector-tag">b</span> + c) <span class="hljs-comment">// call like f (1) (2) (3) or f (1, 2, 3)</span>
                                            <span class="hljs-comment">// or f (1, 2, 3)</span>
                                            <span class="hljs-comment">// or f (1) (2, 3)</span>
                                            <span class="hljs-comment">// etc.</span></code></pre></li>
</ol>
<p>Calling:</p>
<pre class="hljs"><code><span class="hljs-keyword">import</span> { <span class="hljs-built_in">map</span>, } from <span class="hljs-string">'stick-js'</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> = x =&gt; x * <span class="hljs-number">2</span>

<span class="hljs-built_in">map</span> (<span class="hljs-keyword">double</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])    <span class="hljs-comment">// [2, 4, 6] (normal style)</span>
<span class="hljs-built_in">map</span> (<span class="hljs-keyword">double</span>) ([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])   <span class="hljs-comment">// [2, 4, 6] (manual style)</span>
; [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] | <span class="hljs-built_in">map</span> (<span class="hljs-keyword">double</span>) <span class="hljs-comment">// [2, 4, 6] (manual style with stick)</span></code></pre><p>For extra performance you can also limit yourself to the manual style (see
below).</p>
<h2 id="٭-a-note-on-style-٭"><a class="header-link" href="#٭-a-note-on-style-٭"></a>٭ a note on style ٭</h2>
<p>We recommend using a space before the parentheses of a function call.
Admittedly it looks pretty strange at first, but we find that it makes
everything much clearer when you get used to it, in particular with the
manual currying style.</p>
<p>You might also want to check out a vertical alignment plugin. The author
uses <code>vim-easy-align</code> by @junegunn.</p>
<h2 id="٭-markers-٭"><a class="header-link" href="#٭-markers-٭"></a>٭ markers ٭</h2>
<pre class="hljs"><code><span class="hljs-keyword">import</span> { sprintfN, sprintf1, } <span class="hljs-keyword">from</span> <span class="hljs-string">'stick-js'</span>

<span class="hljs-number">3</span> | sprintf1 (<span class="hljs-string">'4 - 1 is %s'</span>) <span class="hljs-comment">// '4 - 1 is 3'</span></code></pre><p>&#39;N&#39; is a marker meaning an array is expected.</p>
<pre class="hljs"><code>; <span class="hljs-selector-attr">[4, 3]</span>
| <span class="hljs-selector-tag">sprintfN</span> (<span class="hljs-string">'%s - 1 is %s'</span>)  <span class="hljs-comment">// same.</span></code></pre><p>&#39;V&#39; means a value is expected, to disambiguate cases where a function also
fits.</p>
<pre class="hljs"><code>import { timesV, timesF, } from 'stick-js'

const { <span class="hljs-built_in">random</span>, } = Math

<span class="hljs-number">3</span>      | timesV (<span class="hljs-number">4</span>)          // [<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>]
<span class="hljs-built_in">random</span> | timesF (<span class="hljs-number">4</span>)          // [&lt;<span class="hljs-built_in">random</span>-<span class="hljs-built_in">num</span>&gt;, &lt;<span class="hljs-built_in">random</span>-<span class="hljs-built_in">num</span>&gt;, &lt;<span class="hljs-built_in">random</span>-<span class="hljs-built_in">num</span>&gt;, &lt;<span class="hljs-built_in">random</span>-<span class="hljs-built_in">num</span>&gt;]
<span class="hljs-built_in">random</span> | timesV (<span class="hljs-number">4</span>)          // [<span class="hljs-built_in">random</span>, <span class="hljs-built_in">random</span>, <span class="hljs-built_in">random</span>, <span class="hljs-built_in">random</span>]</code></pre><p>Note that the last one stores the function in the array.</p>
<pre class="hljs"><code><span class="hljs-built_in">random</span> | timesV (<span class="hljs-number">4</span>) | <span class="hljs-built_in">map</span> (invoke) // [&lt;<span class="hljs-built_in">random</span>-<span class="hljs-built_in">num</span>&gt;, &lt;<span class="hljs-built_in">random</span>-<span class="hljs-built_in">num</span>&gt;, &lt;<span class="hljs-built_in">random</span>-<span class="hljs-built_in">num</span>&gt;, &lt;<span class="hljs-built_in">random</span>-<span class="hljs-built_in">num</span>&gt;]</code></pre><p>&#39;M&#39; means the data is being mutated. In JS we absolutely can not pretend
everything is immutable and we work with mutable data all the time.</p>
<pre class="hljs"><code>import { appendTo, appendToM, } from 'stick-js'
<span class="hljs-built_in">
const </span>a = [1, 2, 3]<span class="hljs-built_in">
const </span>b = 4 | appendTo (a) // functional style: the<span class="hljs-built_in"> array </span>is cloned.
b === a // false
<span class="hljs-built_in">
const </span>a = [1, 2, 3]<span class="hljs-built_in">
const </span>b = 4 | appendToM (a) // non-functional style: the<span class="hljs-built_in"> array </span>is mutated.
b === a // true
<span class="hljs-built_in">
const </span>webGLContext = { ... a complicated object ... }
webGLContext | mergeM ({ someProp: false, }) // you probably want mutable here.</code></pre><p>And there are a few more which we&#39;ll see along the way.</p>
<h2 id="٭-ok,-anaphoric-if-٭"><a class="header-link" href="#٭-ok,-anaphoric-if-٭"></a>٭ ok, anaphoric if ٭</h2>
<p><code>ok (x)</code> is false if <code>x</code> is <code>null</code> or <code>undefined</code>. Every other input returns
<code>true</code>.</p>
<pre class="hljs"><code><span class="hljs-keyword">import</span> { <span class="hljs-built_in">map</span>, ok, notOk, ifOk, } from <span class="hljs-string">'stick-js'</span>

const { <span class="hljs-keyword">log</span>, } = console

; <span class="hljs-meta">[</span><span class="hljs-number">0</span>, <span class="hljs-literal">false</span>, <span class="hljs-string">''</span>, <span class="hljs-built_in">null</span>, <span class="hljs-literal">void</span> <span class="hljs-number">8</span><span class="hljs-meta">]</span>
| map (ok)    // <span class="hljs-meta">[</span><span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span><span class="hljs-meta">]</span>

; <span class="hljs-meta">[</span><span class="hljs-number">0</span>, <span class="hljs-literal">false</span>, <span class="hljs-string">''</span>, <span class="hljs-built_in">null</span>, <span class="hljs-literal">void</span> <span class="hljs-number">8</span><span class="hljs-meta">]</span>
| map (notOk) // <span class="hljs-meta">[</span><span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span><span class="hljs-meta">]</span></code></pre><p>Something we see a lot in JS in the wild is:</p>
<pre class="hljs"><code><span class="hljs-keyword">let</span> answer
<span class="hljs-keyword">if</span> (someVar !== <span class="hljs-literal">undefined</span> &amp;&amp; someVar !== <span class="hljs-literal">null</span>) {
  answer = someVar + <span class="hljs-number">1</span>
} <span class="hljs-keyword">else</span> {
  answer = <span class="hljs-string">'nothing'</span>
}</code></pre><p>This can vastly improved using an &#39;anaphoric if&#39; and a stick idiom:</p>
<pre class="hljs"><code>import { <span class="hljs-keyword">add</span>, always, } <span class="hljs-keyword">from</span> <span class="hljs-string">'stick-js'</span>

<span class="hljs-keyword">const</span> add1 = <span class="hljs-number">1</span> | <span class="hljs-keyword">add</span>                                     <span class="hljs-comment">// or add (1)</span>
<span class="hljs-keyword">const</span> answer = someVar | ifOk (add1, <span class="hljs-string">'nothing'</span> | always)</code></pre><p>Explanation: <code>ifOk</code> takes two functions -- a &#39;then&#39; function and an &#39;else&#39; function.
In the &#39;ok&#39;    case, the value being tested is passed to the function. (This
bound value is sometimes called an &#39;anaphor&#39;).</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> add1IfYouCan = val =&gt; val | ifOk (
  <span class="hljs-comment">// `that` refers to `val`</span>
  that =&gt; that + <span class="hljs-number">1</span>,

  <span class="hljs-comment">// no value is passed.</span>
  _ =&gt; <span class="hljs-string">'nothing'</span>,
)</code></pre><p>This can be further condensed, using &#39;point-free style&#39; (see below) and the <code>always</code> function:</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> add1IfYouCan = ifOk (<span class="hljs-number">1</span> | <span class="hljs-keyword">add</span>, <span class="hljs-string">'nothing'</span> | always)</code></pre><p>Usage:</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> answer = someVar | add1IfYouCan

; [<span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">void</span> <span class="hljs-number">8</span>]
| <span class="hljs-built_in">map</span> (add1IfYouCan) <span class="hljs-comment">// [1, 11, 'nothing', 'nothing']</span></code></pre><h2 id="٭-point-free-٭"><a class="header-link" href="#٭-point-free-٭"></a>٭ point-free ٭</h2>
<p>A common pattern is when the argument to a function is passed immediately into a pipe:</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> add1IfYouCan = <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x | ifOk (add1, <span class="hljs-string">'nothing'</span> | always)</code></pre><p>Since <code>x</code> does not appear anywhere else in the expression, we can simply remove it, along with the function argument:</p>
<pre class="hljs"><code>const add1IfYouCan = ifOk (<span class="hljs-name">add1</span>, 'nothing' | always)</code></pre><p>This is often called &#39;point-free&#39; style. It means the function arguments and
the data being passed through the pipeline have been abstracted away (and
has nothing to do with dots, despite the name).</p>
<p>If the pipe chain consists of more than 1 link …</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> { dot, sprintf1, tap, }
<span class="hljs-keyword">const</span> { log, } = <span class="hljs-built_in">console</span>

<span class="hljs-keyword">const</span> add1IfYouCan = <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x
  | ifOk (add1, <span class="hljs-string">'nothing'</span> | always)
  | <span class="hljs-built_in">String</span>                        <span class="hljs-comment">// conversion using type constructor</span>
  | dot (<span class="hljs-string">'toUpperCase'</span>)
  | sprintf1 (<span class="hljs-string">'The answer is %s'</span>)
  | tap (log)                     <span class="hljs-comment">// outputs 'The answer is 1', 'The answer is NOTHING', ...</span></code></pre><p>… then we remove the <code>x =&gt; x</code> and change all the <code>|</code> to <code>&gt;&gt;</code></p>
<pre class="hljs"><code>const add1IfYouCan =
  ifOk (<span class="hljs-name">add1</span>, 'nothing' | always)  // (<span class="hljs-number">1</span>)
  &gt;&gt; String                        // (<span class="hljs-number">2</span>)
  &gt;&gt; dot ('toUpperCase')           // (<span class="hljs-number">3</span>)
  &gt;&gt; sprintf1 ('The answer is %s') // (<span class="hljs-number">4</span>)
  &gt;&gt; tap (<span class="hljs-name">log</span>)                     // (<span class="hljs-number">5</span>)</code></pre><p>The following pattern always holds:</p>
<pre class="hljs"><code>a | <span class="hljs-type">b</span> | <span class="hljs-type">c</span> = a | <span class="hljs-type">(b</span> &gt;&gt; c)</code></pre><p>So when the chains start to get long (as above), you can cut pieces out
using this property. For example, you can refactor lines 2-4 into a new
function:</p>
<pre class="hljs"><code>// --- convert input <span class="hljs-keyword">to</span> <span class="hljs-built_in">String</span>, make uppercase, perform sprintf.
<span class="hljs-keyword">const</span> processString = <span class="hljs-built_in">String</span>
  &gt;&gt; dot (<span class="hljs-string">'toUpperCase'</span>)
  &gt;&gt; sprintf1 (<span class="hljs-string">'The answer is %s'</span>)</code></pre><p>And splice it back in:</p>
<pre class="hljs"><code>const add1IfYouCan = x =&gt; x
  | <span class="hljs-type">ifOk</span> (add1, 'nothing' | <span class="hljs-type">always</span>)
  | <span class="hljs-type">processString</span>
  | <span class="hljs-type">tap</span> (log)</code></pre><p>Or</p>
<pre class="hljs"><code>const add1IfYouCan =
  ifOk (<span class="hljs-name">add1</span>, 'nothing' | always)
  &gt;&gt; processString
  &gt;&gt; tap (<span class="hljs-name">log</span>)</code></pre><h2 id="٭-compositional-predicates-٭"><a class="header-link" href="#٭-compositional-predicates-٭"></a>٭ compositional predicates ٭</h2>
<p><code>ifOk</code> is a convenience for <code>ifPredicate (ok)</code> or <code>ok | ifPredicate</code>.</p>
<p>There is also a &#39;when&#39; form, which has no &#39;else&#39; branch.</p>
<pre class="hljs"><code>import { <span class="hljs-keyword">add</span>, whenOk, } <span class="hljs-keyword">from</span> <span class="hljs-string">'stick-js'</span>

<span class="hljs-keyword">const</span> add1 = <span class="hljs-number">1</span> | <span class="hljs-keyword">add</span> <span class="hljs-comment">// or add (1)</span>

<span class="hljs-number">3</span>    | whenOk (add1) <span class="hljs-comment">// 4</span>
<span class="hljs-literal">null</span> | whenOk (add1) <span class="hljs-comment">// undefined</span></code></pre><p>The selection of <code>if</code> and <code>when</code> functions we provide is intentionally skimpy, to encourage you to compose your own.</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> { <span class="hljs-built_in">floor</span>, } = Math

<span class="hljs-comment">// --- predicate to match integers.</span>
<span class="hljs-keyword">const</span> isInteger = x =&gt; x === <span class="hljs-built_in">floor</span> (x)

<span class="hljs-comment">// --- or how about</span>
<span class="hljs-comment">// import { eq, } from 'stick-js'</span>
<span class="hljs-comment">// const isInteger = x =&gt; x | floor | eq (x)</span>

<span class="hljs-comment">// --- or if you're getting bored:</span>
<span class="hljs-comment">// import { timesV, asteriskN, passToN, } from 'stick-js'</span>
<span class="hljs-comment">// const arrowSnd = f =&gt; timesV (2) &gt;&gt; asteriskN ([id, f])</span>
<span class="hljs-comment">// const isInteger = arrowSnd (floor) &gt;&gt; passToN (eq)</span>

<span class="hljs-comment">// --- now compose it into an anaphoric if:</span>

<span class="hljs-keyword">const</span> ifInteger = isInteger | ifPredicate

<span class="hljs-comment">// --- now use it:</span>

<span class="hljs-keyword">const</span> add1 = <span class="hljs-built_in">add</span> (<span class="hljs-number">1</span>)

; [<span class="hljs-number">3.5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4.2</span>]
| <span class="hljs-built_in">map</span> (ifInteger (add1, <span class="hljs-string">'nothing'</span> | always))
  <span class="hljs-comment">// ['nothing', 5, 'nothing']</span></code></pre><p>More complicated predicates:</p>
<pre class="hljs"><code>// --- <span class="hljs-meta">@todo</span> use <span class="hljs-string">`allN`</span>
<span class="hljs-keyword">const</span> both = (f, g) =&gt; x =&gt; f (x) &amp;&amp; g (x)

<span class="hljs-keyword">const</span> isOdd = x =&gt; x % <span class="hljs-number">2</span>

<span class="hljs-keyword">const</span> isOddInteger = both (isInteger, isOdd)
<span class="hljs-keyword">const</span> ifOddInteger = isOddInteger | ifPredicate

; [<span class="hljs-number">3.5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5.5</span>]
| map (ifOddInteger (
  add1,
  '<span class="hljs-literal">nothing</span>' | always,
))
// ['<span class="hljs-literal">nothing</span>', '<span class="hljs-literal">nothing</span>', <span class="hljs-number">6</span>, '<span class="hljs-literal">nothing</span>']

; [<span class="hljs-number">3.5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5.5</span>] | map (isOddInteger)
// [<span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>]</code></pre><p>Note that <code>ifPredicate</code> and <code>whenPredicate</code> match on truthiness, not strict
truth. Rationale: that is how the native <code>filter</code> works, and JS&#39;s <code>if</code>
operator, and many other tools in e.g. <code>Ramda</code>; and it&#39;s trivial to convert
a truthy expression to a strict one.</p>
<h2 id="٭-compositional-decoration-٭"><a class="header-link" href="#٭-compositional-decoration-٭"></a>٭ compositional decoration ٭</h2>
<p>Our <code>map</code> function is capped at one argument, meaning the map routine only
gets the value and not the index or the collection.</p>
<pre class="hljs"><code><span class="hljs-keyword">import</span> { map, addIndex, addCollection, } <span class="hljs-keyword">from</span> <span class="hljs-string">'stick-js'</span>

; [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]
| map (<span class="hljs-function"><span class="hljs-params">(x, idx)</span> =&gt;</span> idx) <span class="hljs-regexp">//</span> [<span class="hljs-literal">undefined</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-literal">undefined</span>]</code></pre><p>But:</p>
<pre class="hljs"><code>const mapWithIndex = map | <span class="hljs-type">addIndex</span>
const mapWithCollection = map | <span class="hljs-type">addCollection</span>

; [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]
| <span class="hljs-type">mapWithIndex</span> ((x, idx) =&gt; idx) // [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]

; [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]
| <span class="hljs-type">mapWithCollection</span> ((x, coll) =&gt; coll) // [[<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]]

; [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]
| <span class="hljs-type">(map</span> | <span class="hljs-type">addIndex</span> | <span class="hljs-type">addCollection</span>) ((x, idx, coll) =&gt; ...)

; [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]
| <span class="hljs-type">(map</span> | <span class="hljs-type">addCollection</span> | <span class="hljs-type">addIndex</span>) ((x, coll, idx) =&gt; ...)</code></pre><p>We can also enhance our merge functions, to deal with conflicts:</p>
<pre class="hljs"><code><span class="hljs-keyword">import</span> { mergeWith, mergeToSym, } <span class="hljs-keyword">from</span> <span class="hljs-string">'stick-js'</span>

<span class="hljs-keyword">const</span> chooseTgt = <span class="hljs-function">(<span class="hljs-params">src, tgt</span>) =&gt;</span> tgt
<span class="hljs-keyword">const</span> chooseSrc = <span class="hljs-function">(<span class="hljs-params">src, tgt</span>) =&gt;</span> src

<span class="hljs-comment">// --- choose target value on conflict</span>
<span class="hljs-keyword">const</span> mergeChooseTgt = mergeToSym | mergeWith (chooseTgt)

<span class="hljs-comment">// --- choose source value on conflict</span>
<span class="hljs-keyword">const</span> mergeChooseSrc = mergeToSym | mergeWith (chooseSrc)

<span class="hljs-keyword">const</span> os = { <span class="hljs-attr">name</span>: <span class="hljs-string">'source name'</span>, }
<span class="hljs-keyword">const</span> ot = { <span class="hljs-attr">name</span>: <span class="hljs-string">'target name'</span>, }

os | mergeChooseSrc (ot) <span class="hljs-comment">// 'source name'</span>
os | mergeChooseTgt (ot) <span class="hljs-comment">// 'target name'</span></code></pre><p>Or to only merge if certain conditions hold:</p>
<pre class="hljs"><code>import { mergeWhen, eq, } from <span class="hljs-string">'stick-js'</span>

const { <span class="hljs-built_in">floor</span>, } = Math
const isInteger = <span class="hljs-keyword">x</span> =&gt; <span class="hljs-keyword">x</span> | <span class="hljs-built_in">floor</span> | eq (<span class="hljs-keyword">x</span>)
const srcIsInteger = (src, tgt) =&gt; src | isInteger
const mergeToWhenSrcIsInteger = mergeToSym | mergeWhen (srcIsInteger)

const os = { va<span class="hljs-variable">l:</span> <span class="hljs-number">2.2</span>, <span class="hljs-keyword">vi</span><span class="hljs-variable">l:</span> <span class="hljs-number">3</span>,  vo<span class="hljs-variable">l:</span> <span class="hljs-number">3.5</span>, }
const ot = { va<span class="hljs-variable">l:</span> <span class="hljs-number">25</span>,  <span class="hljs-keyword">vi</span><span class="hljs-variable">l:</span> <span class="hljs-number">25</span>, vo<span class="hljs-variable">l:</span> <span class="hljs-number">25</span>,  <span class="hljs-keyword">ve</span><span class="hljs-variable">l:</span> <span class="hljs-number">42</span>, }

os | mergeTo (ot)                 // { va<span class="hljs-variable">l:</span> <span class="hljs-number">2.2</span>, <span class="hljs-keyword">vi</span><span class="hljs-variable">l:</span> <span class="hljs-number">3</span>, vo<span class="hljs-variable">l:</span> <span class="hljs-number">3.5</span>, <span class="hljs-keyword">ve</span><span class="hljs-variable">l:</span> <span class="hljs-number">42</span>, }
os | mergeToWhenSrcIsInteger (ot) // { va<span class="hljs-variable">l:</span> <span class="hljs-number">25</span>,  <span class="hljs-keyword">vi</span><span class="hljs-variable">l:</span> <span class="hljs-number">3</span>, vo<span class="hljs-variable">l:</span> <span class="hljs-number">25</span>,  <span class="hljs-keyword">ve</span><span class="hljs-variable">l:</span> <span class="hljs-number">42</span>, }</code></pre><h2 id="٭-semantics-and-argument-order-are-based-where-possible-on-english-grammar-٭"><a class="header-link" href="#٭-semantics-and-argument-order-are-based-where-possible-on-english-grammar-٭"></a>٭ semantics and argument order are based where possible on English grammar ٭</h2>
<p>(We&#39;re dying to see a port to Hungarian, too)</p>
<p>Once you master this, the usage becomes intuitive and greatly reduces the
need to look things up.</p>
<p>(Motivation: what&#39;s the argument order of <code>append</code>, <code>times</code>, and <code>subtract</code> in your favorite library?)</p>
<pre class="hljs"><code>import {
  sprintfN, sprintf1, mergeTo, merge, prependTo, prepend,
  appendTo, append, <span class="hljs-built_in">bind</span>PropTo, <span class="hljs-built_in">bind</span>Prop, <span class="hljs-built_in">bind</span>To, <span class="hljs-built_in">bind</span>, invoke,
} from <span class="hljs-string">'stick-js'</span>

const tgt = { thing: <span class="hljs-string">'sandwich'</span>, want: <span class="hljs-string">'no thanks'</span>,  }
const src = {                    want: <span class="hljs-string">'yes please'</span>, }</code></pre><p>When a function ends in a preposition, for example, ‘To’, the identifier to
the right is the object of the preposition.</p>
<p>Read this as ‘merge src <strong>to tgt</strong>’</p>
<pre class="hljs"><code>src | mergeTo (tgt)                  // { thin<span class="hljs-variable">g:</span> <span class="hljs-string">'sandwich'</span>, wan<span class="hljs-variable">t:</span> <span class="hljs-string">'yes please'</span>, }</code></pre><p>The same function without the preposition means that the identifier to the right is the object of the verb ‘merge’.</p>
<p>Read this as: ‘<strong>merge src</strong> to tgt’</p>
<pre class="hljs"><code>tgt | merge (src)                    // { thing: 'sandwich', want: 'yes please', }

4 | appendTo ([1, 2, 3])             // [1, 2, 3, 4]
; ([1, 2, 3]) | append (4)           // [1, 2, 3, 4]

0 | prependTo ([1, 2, 3])            // [0, 1, 2, 3]
; ([1, 2, 3]) | prepend (0)          // [0, 1, 2, 3]
<span class="hljs-built_in">
const </span>dog = {
  name: 'Caesar',
  speak () {<span class="hljs-built_in"> return </span>'My name is ' + this.name },
}
<span class="hljs-built_in">
const </span>cat = {
  name: 'Fritz',
  speak () {<span class="hljs-built_in"> throw </span>new Error },
}
<span class="hljs-built_in">
const </span>f = 'speak' | bindPropTo (dog)
f ()                                  // 'My name is Caesar'

// --- 'bind prop <span class="hljs-string">"speak"</span> to object'
'speak' | bindPropTo (dog)   |<span class="hljs-built_in"> invoke </span>// same

// --- also 'bind prop <span class="hljs-string">"speak"</span> to object'
dog     | bindProp ('speak') |<span class="hljs-built_in"> invoke </span>// same

dog.speak | bindTo (dog) |<span class="hljs-built_in"> invoke </span>    // same

// cat.speak ()                       // Error
dog.speak | bindTo (cat) |<span class="hljs-built_in"> invoke </span>    // 'My name is Fritz'
cat | bind (dog.speak)   |<span class="hljs-built_in"> invoke </span>    // 'My name is Fritz'

// --- 'call this function on this context', i.e., bind<span class="hljs-built_in"> and </span>call.
; ({}.toString) | callOn (3)          // '[object Number]'

// --- 'provide this context to this function'
; 3 | provideTo ({}.toString)         // '[object Number]'</code></pre><p>Note that this fits the <code>a | b | c</code> pattern:</p>
<pre class="hljs"><code>dog.speak | bindTo (cat) |<span class="hljs-built_in"> invoke </span>    // 'My name is Fritz'</code></pre><p>So we can also write it as <code>a | (b &gt;&gt; c)</code>:</p>
<pre class="hljs"><code>dog.speak | (bindTo (cat) &gt;&gt; invoke)  // <span class="hljs-symbol">'My</span> name <span class="hljs-keyword">is</span> Fritz'</code></pre><p>In fact <code>bindTo (x) &gt;&gt; invoke</code> is already provided under the name <code>callOn</code>,
and its inverse <code>provideTo</code>:</p>
<pre class="hljs"><code>dog.speak | callOn (cat)              // <span class="hljs-symbol">'My</span> name <span class="hljs-keyword">is</span> Fritz'
cat       | provideTo (dog.speak)     // <span class="hljs-symbol">'My</span> name <span class="hljs-keyword">is</span> Fritz'</code></pre><p>Some other miscellaneous examples.</p>
<pre class="hljs"><code><span class="hljs-comment">// --- '3 to the 4th'</span>
<span class="hljs-number">3</span> | toThe (<span class="hljs-number">4</span>)                         <span class="hljs-comment">// 81</span>

<span class="hljs-comment">// --- 'divide 3 by 6' or '3 divided by 6'</span>
<span class="hljs-number">3</span> | divideBy (<span class="hljs-number">6</span>)                      <span class="hljs-comment">// 0.5</span>

<span class="hljs-comment">// --- 'divide 3 into 6'</span>
<span class="hljs-number">3</span> | divideInto (<span class="hljs-number">6</span>)                    <span class="hljs-comment">// 2</span>

<span class="hljs-comment">// --- 'subtract 3 from 4'</span>
<span class="hljs-number">3</span> | subtractFrom (<span class="hljs-number">4</span>)                  <span class="hljs-comment">// 1</span>

<span class="hljs-comment">// --- 'subtract 4 from 3'</span>
<span class="hljs-number">3</span> | subtract (<span class="hljs-number">4</span>)                      <span class="hljs-comment">// -1</span>

<span class="hljs-comment">// --- '3 minus 4'</span>
<span class="hljs-number">3</span> | minus (<span class="hljs-number">4</span>)                         <span class="hljs-comment">// -1</span></code></pre><h2 id="٭-side-effects-&-chaining-٭-mutable-vs-immutable-٭"><a class="header-link" href="#٭-side-effects-&-chaining-٭-mutable-vs-immutable-٭"></a>٭ side effects &amp; chaining ٭ mutable vs immutable ٭</h2>
<pre class="hljs"><code><span class="hljs-keyword">import</span> {
  <span class="hljs-keyword">map</span>, side1, appendM, <span class="hljs-built_in">append</span>, prependM, prepend,
} from <span class="hljs-string">'stick-js'</span></code></pre><p>Chaining with the <code>.</code> will often not do what you want.</p>
<pre class="hljs"><code>; [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]
  .push (<span class="hljs-number">5</span>)
  .unshift (<span class="hljs-number">1</span>) <span class="hljs-comment">// error, return value of previous line was 5</span></code></pre><p>But this will:</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> push    = <span class="hljs-string">'push'</span>    | side1
<span class="hljs-keyword">const</span> unshift = <span class="hljs-string">'unshift'</span> | side1</code></pre><p>The 1 in side1 refers to the arity of the function, i.e., the exact number
of arguments it expects. When working with functions in this way it&#39;s
important to specify this.</p>
<p><code>.push</code> and <code>.unshift</code>, both methods of <code>Array.prototype</code>, expect exactly
one argument, hence <code>side1</code> in both cases.</p>
<pre class="hljs"><code>; [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]
| push (<span class="hljs-number">5</span>)
| unshift (<span class="hljs-number">1</span>) <span class="hljs-comment">// [1, 2, 3, 4, 5]</span>

<span class="hljs-comment">// --- using stick functions for mutable data:</span>

; [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]
| appendM (<span class="hljs-number">5</span>)
| prependM (<span class="hljs-number">1</span>)

<span class="hljs-comment">// --- using stick functions for immutable data:</span>

; [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]
| append (<span class="hljs-number">5</span>)  <span class="hljs-comment">// new array [2, 3, 4, 5]</span>
| prepend (<span class="hljs-number">1</span>) <span class="hljs-comment">// new array [1, 2, 3, 4, 5]</span></code></pre><p>You can insert <code>tap</code> anywhere in the chain, which is guaranteed not to mess
with the pipeline no matter what it returns:</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> double = <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x * <span class="hljs-number">2</span>

; [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]
| map (double)               <span class="hljs-comment">// [2, 4]</span>
| tap (<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> <span class="hljs-built_in">console</span>.log (x)) <span class="hljs-comment">// still [2, 4], performs side-effect (printing)</span>
| tap (<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> [<span class="hljs-number">100</span>, <span class="hljs-number">200</span>])      <span class="hljs-comment">// still [2, 4], for demonstration only</span>
| join (<span class="hljs-string">','</span>)
<span class="hljs-comment">// '2,4'</span></code></pre><p>Without the first <code>tap</code>, this would have been an error, because
<code>console.log</code> returns <code>undefined</code>.</p>
<p><code>tap</code> is useful to signal the intention of performing side effects or IO. It
is also really useful for debugging. And our <code>side</code> family of functions use
<code>tap</code> under the hood.</p>
<h2 id="٭-factory-٭-synopsis-٭"><a class="header-link" href="#٭-factory-٭-synopsis-٭"></a>٭ factory ٭ synopsis ٭</h2>
<pre class="hljs"><code><span class="hljs-keyword">import</span> {
  <span class="hljs-keyword">factory</span>, factoryProps,
  factoryStatics,
} from <span class="hljs-string">'stick-js'</span>

<span class="hljs-comment">// --- dog.js:</span>
<span class="hljs-keyword">const</span> proto = {
  init () {
    ...
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>
  },
  breathe () { <span class="hljs-keyword">return</span> <span class="hljs-string">'huff'</span> },
  whoami ()  { <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name },
  getType () { <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.type },
}

<span class="hljs-keyword">const</span> props = {
  type: <span class="hljs-string">'dog'</span>,
  name: undefined,
}

<span class="hljs-comment">// --- basic:</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> proto | <span class="hljs-keyword">factory</span>

<span class="hljs-comment">// --- variants:</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> proto | <span class="hljs-keyword">factory</span> | factoryProps (props)
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> proto | <span class="hljs-keyword">factory</span> | factoryStatics ({ ... }) | factoryProps (props)

<span class="hljs-comment">// ------ main.js</span>

<span class="hljs-keyword">import</span> Dog from <span class="hljs-string">'./dog'</span>

<span class="hljs-keyword">const</span> dog = Dog.create ()
<span class="hljs-comment">// const dog = Dog.create ().init () // useful in practice</span>
dog.breathe ()                       <span class="hljs-comment">// 'huff'</span>
dog.type                             <span class="hljs-comment">// 'dog', if `factoryProps` used</span>
dog.getType ()                       <span class="hljs-comment">// 'dog', same</span>
dog.whoami ()                        <span class="hljs-comment">// undefined, because no default.</span>

<span class="hljs-keyword">const</span> dog2 = Dog.create ({ name: <span class="hljs-string">'garfunkel'</span>, })
dog2.whoami ()                       <span class="hljs-comment">// 'garfunkel', thanks to args to create</span></code></pre><h2 id="٭-factory-٭-with-mixins-٭-synopsis-٭"><a class="header-link" href="#٭-factory-٭-with-mixins-٭-synopsis-٭"></a>٭ factory ٭ with mixins ٭ synopsis ٭</h2>
<pre class="hljs"><code><span class="hljs-comment">// ------ animal.js:</span>

<span class="hljs-keyword">import</span> {
  factory, factoryStatics, mixinM, mixinPreM,
  factoryProps,
  ifPredicate,
} <span class="hljs-keyword">from</span> <span class="hljs-string">'stick-js'</span>

<span class="hljs-keyword">const</span> isOdd = <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x % <span class="hljs-number">2</span> !== <span class="hljs-number">0</span>
<span class="hljs-keyword">const</span> ifOdd = isOdd | ifPredicate

<span class="hljs-comment">// --- a 'base' object (animal)</span>

<span class="hljs-keyword">const</span> proto = {
  init () {
    ...
    return <span class="hljs-keyword">this</span>
  },
  move () {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.numLegs | ifOdd (
      <span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> <span class="hljs-string">'hobble'</span>,
      _ =&gt; <span class="hljs-string">'gait'</span>,
    )
  },
  breathe () { <span class="hljs-keyword">return</span> <span class="hljs-string">'huff'</span> },
  speak ()   { <span class="hljs-string">'not implemented'</span> | die },
  getType () { <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.type },
}

<span class="hljs-keyword">const</span> props = {
  <span class="hljs-attr">type</span>: <span class="hljs-string">'animal'</span>,
  <span class="hljs-attr">numLegs</span>: <span class="hljs-literal">undefined</span>,
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> proto | factory | factoryProps (props)

<span class="hljs-comment">// ------ cheater.js:</span>

<span class="hljs-comment">// --- some orthogonal functionality</span>

<span class="hljs-keyword">const</span> proto = {
  <span class="hljs-attr">cheat</span>: <span class="hljs-function"><span class="hljs-params">howMuch</span> =&gt;</span> <span class="hljs-string">'I cheat '</span> + howMuch,
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> proto | factory

<span class="hljs-comment">// ------ dog.js:</span>

<span class="hljs-keyword">import</span> {
  sprintf1,
  factory,
} <span class="hljs-keyword">from</span> <span class="hljs-string">'stick-js'</span>

<span class="hljs-keyword">import</span> Animal <span class="hljs-keyword">from</span> <span class="hljs-string">'./animal'</span>
<span class="hljs-keyword">import</span> Cheater <span class="hljs-keyword">from</span> <span class="hljs-string">'./cheater'</span>

<span class="hljs-keyword">const</span> { <span class="hljs-attr">proto</span>: animalProto, } = Animal
<span class="hljs-keyword">const</span> { <span class="hljs-attr">proto</span>: cheaterProto, } = Cheater

<span class="hljs-comment">// --- a composite object (dog), extended from animal, with extra functions mixed in.</span>

<span class="hljs-keyword">const</span> proto = {
  init () {
    ...
    return <span class="hljs-keyword">this</span>
  },
  speak () { <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name | sprintf1 (<span class="hljs-string">'Dog %s says woof'</span>) }
}

<span class="hljs-keyword">const</span> props = {
  <span class="hljs-attr">type</span>: <span class="hljs-string">'dog'</span>,
  <span class="hljs-attr">numLegs</span>: <span class="hljs-number">4</span>,
  <span class="hljs-attr">name</span>: <span class="hljs-literal">undefined</span>,
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> proto
  | mixinPreM (animalProto)
  | mixinM (cheaterProto)
  | factory
  | factoryProps (props)

<span class="hljs-comment">// ------ main.js</span>

<span class="hljs-keyword">import</span> Dog <span class="hljs-keyword">from</span> <span class="hljs-string">'./dog'</span>

<span class="hljs-keyword">const</span> dog = Dog.create ({ <span class="hljs-attr">name</span>: <span class="hljs-string">'garfunkel'</span>, })
<span class="hljs-comment">// const dog = Dog.create ({ name: 'garfunkel', }).init () // with init</span>
dog.breathe ()                                  <span class="hljs-comment">// 'huff' (from animal)</span>
dog.getType ()                                  <span class="hljs-comment">// 'dog' (function from animal, property from dog)</span>
dog.speak ()                                    <span class="hljs-comment">// 'Dog garfunkel says woof' (function from dog, property from instance initialisation)</span>
dog.cheat (<span class="hljs-string">'a bit'</span>)                             <span class="hljs-comment">// 'I cheat a bit' (from cheater)</span></code></pre><p>Stick idioms:</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> breathe = dot (<span class="hljs-string">'breathe'</span>)
<span class="hljs-keyword">const</span> getType = dot (<span class="hljs-string">'getType'</span>)
<span class="hljs-keyword">const</span> speak = dot (<span class="hljs-string">'speak'</span>)
<span class="hljs-keyword">const</span> cheat = dot1 (<span class="hljs-string">'cheat'</span>)
<span class="hljs-keyword">const</span> init = side (<span class="hljs-string">'init'</span>)
<span class="hljs-keyword">const</span> <span class="hljs-keyword">create</span> = dot1 (<span class="hljs-string">'create'</span>)

<span class="hljs-keyword">const</span> dog = Dog
  | <span class="hljs-keyword">create</span> (<span class="hljs-comment">{ name: 'garfunkel', }</span>)
  | init

dog | breathe
dog | getType
dog | speak

Dog | <span class="hljs-keyword">create</span> (<span class="hljs-comment">{ name: 'garfunkel', }</span>)
    | init
    | cheat</code></pre><h2 id="٭-factory-٭-explained"><a class="header-link" href="#٭-factory-٭-explained"></a>٭ factory ٭ explained</h2>
<p>We provide a functional style for working with objects the way JS was
designed to: using prototypical inheritance and Object.create. We hope to
show you that the <code>new</code> keyword and &#39;classes&#39; and all the baggage they bring
are unnecessary, and that they obfuscate the way that it actually works.</p>
<p>We provide a simple abstraction for factories, with as little sugar
and magic as possible, and encourage you to mix and match the components to
do exactly what you need.</p>
<p>To recap: you create an object in JS by first building a prototype object,
consisting of only functions.</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> animalProto = {
  breathe () { <span class="hljs-keyword">return</span> <span class="hljs-string">'huff'</span> },
  speak () { <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span> },
  ...
}</code></pre><p>To make an <code>animal</code> instance, you pass this prototype object to Object.create,
then assign properties. If you wish you can treat one of these instances as
a prototype for a new kind of object, a <code>dog</code> for example, copy in some
more functions, use Object.create again, and so on.</p>
<p>We encapsulate this process with the notion of a factory, which is an object
which knows how to spawn objects of a certain type.</p>
<pre class="hljs"><code><span class="hljs-keyword">import</span> { <span class="hljs-keyword">factory</span>, } from <span class="hljs-string">'stick-js'</span>

<span class="hljs-keyword">const</span> animalProto = {
  breathe () { <span class="hljs-keyword">return</span> <span class="hljs-string">'huff'</span> },
  speak () { <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error },
  ...
}

<span class="hljs-keyword">const</span> Animal = animalProto | <span class="hljs-keyword">factory</span> <span class="hljs-comment">// other idioms might call it `animal` or `animalFactory`</span>
<span class="hljs-keyword">const</span> animal1 = Animal.create ()
<span class="hljs-keyword">const</span> animal2 = Animal.create ()
animal1.breathe () <span class="hljs-comment">// 'huff'</span>
animal2.breathe () <span class="hljs-comment">// 'huff'</span>
animal2.speak () <span class="hljs-comment">// Error</span></code></pre><p>To add properties:</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> animalProps = {
  <span class="hljs-keyword">type</span>: <span class="hljs-string">'animal'</span>,
  size: <span class="hljs-literal">undefined</span>,
  numLegs: <span class="hljs-literal">undefined</span>,
}</code></pre><p>And we recommend always having an <code>init</code> method, which you will almost certainly
need. <code>myFactory.create ().init ()</code> becomes a well-worn pattern.</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> isOdd = x =&gt; x % <span class="hljs-number">2</span> !== <span class="hljs-number">0</span>
<span class="hljs-keyword">const</span> ifOdd = isOdd | ifPredicate

<span class="hljs-keyword">const</span> animalProto = {
  init () {
    ...
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>
  },
  breathe () { <span class="hljs-keyword">return</span> <span class="hljs-string">'huff'</span> },
  speak () { <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error },
  move () {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.numLegs | ifOdd (
      _ =&gt; <span class="hljs-string">'hobble'</span>,
      _ =&gt; <span class="hljs-string">'gait'</span>,
    )
  },
}

<span class="hljs-keyword">const</span> Animal = animalProto | <span class="hljs-keyword">factory</span> | factoryProps (animalProps)</code></pre><p>On <code>create</code>, the properties which are &#39;ok&#39; will get copied in to the new
object.</p>
<p>The others are there for documentation: put them here, not peppered
throughout the methods. Do use <code>undefined</code> for props that are waiting to be
defined, which is arguably better than <code>null</code> and definitely better than
<code>false</code>. Use <code>void 8</code> or your very own favorite number to impress … no one.</p>
<pre class="hljs"><code>const animal = Animal<span class="hljs-selector-class">.create</span> ()<span class="hljs-selector-class">.init</span> ()
animal<span class="hljs-selector-class">.type</span> <span class="hljs-comment">// 'animal'</span>
animal<span class="hljs-selector-class">.size</span> <span class="hljs-comment">// undefined</span></code></pre><p>You can pass an object to <code>create</code> to initialise properties. These will be
copied in <em>after</em> the props that were passed to <code>factoryProps</code> are.</p>
<pre class="hljs"><code>const bigBiped = Animal<span class="hljs-selector-class">.create</span> ({ size: <span class="hljs-string">'big'</span>, numLegs: <span class="hljs-number">2</span>, })<span class="hljs-selector-class">.init</span> ()</code></pre><p>You can also eliminate the dots entirely:</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> create = dot1 (<span class="hljs-string">'create'</span>)
<span class="hljs-keyword">const</span> init   = side (<span class="hljs-string">'init'</span>)
<span class="hljs-keyword">const</span> <span class="hljs-built_in">move</span>   = dot  (<span class="hljs-string">'move'</span>)
<span class="hljs-keyword">const</span> speak  = dot  (<span class="hljs-string">'speak'</span>)

Animal | create ({ <span class="hljs-built_in">size</span>: <span class="hljs-string">'small'</span>, numLegs: <span class="hljs-number">2</span>, })
       | init
       | <span class="hljs-built_in">move</span> <span class="hljs-comment">// 'gait'</span></code></pre><p>Note that by using <code>side</code> for <code>init</code> we are assured that the instance is
passed down through the pipe and not the return value of <code>init</code> (although in
this case, <code>init</code> returns <code>this</code>, so <code>dot</code> would have worked too.) <code>create</code>
and <code>move</code> definitely need <code>dot</code> and not <code>side</code>.</p>
<p>To extend <code>Animal</code> to the obligatory <code>Dog</code> find the <code>Animal</code> prototype
(if <code>animalProto</code> is not in scope).</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> animalProto = Animal.proto</code></pre><p>Or</p>
<pre class="hljs"><code>const animalProto = Animal.create ().__proto__ // might <span class="hljs-keyword">not</span> be available <span class="hljs-keyword">in</span> <span class="hljs-keyword">all</span> runtimes</code></pre><p>Create it, add dog methods, and make a new factory:</p>
<pre class="hljs"><code>const dogProto = animalProto
  | Object.create
  | mergeM ({
    speak () { <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.loud ? <span class="hljs-string">'WOOF'</span> : <span class="hljs-string">'woof'</span> },
  })

const dogProps = {
  numLegs: <span class="hljs-number">4</span>,
  loud: <span class="hljs-literal">undefined</span>,
}

const Dog = dogProto | factory | factoryProps (dogProps)

; [<span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>]
| map (<span class="hljs-function"><span class="hljs-params">(loudness)</span> =&gt;</span> Dog
  | create ({ loud: loudness, })
  | (dog =&gt; [dog.speak (), dog.breathe (), dog.move ()])
)
<span class="hljs-regexp">//</span> [[<span class="hljs-string">'WOOF'</span>, <span class="hljs-string">'huff'</span>, <span class="hljs-string">'gait'</span>], [<span class="hljs-string">'woof'</span>, <span class="hljs-string">'huff'</span>, <span class="hljs-string">'gait'</span>]]</code></pre><p>Note that we can call methods of both <code>Animal</code> and <code>Dog</code> now.</p>
<h2 id="٭-factory-٭-with-mixins-٭-explained-٭"><a class="header-link" href="#٭-factory-٭-with-mixins-٭-explained-٭"></a>٭ factory ٭ with mixins ٭ explained ٭</h2>
<pre class="hljs"><code>const Dog = dogProto | <span class="hljs-type">mixinM</span> (animalProto) | <span class="hljs-type">factory</span> | <span class="hljs-type">factoryProps</span> (dogProps)</code></pre><p>Working with mixins is tricky. At some point, there will be namespace
conflicts and it&#39;s not always obvious which version should win out -- and
you have to decide how you want to deal with that.</p>
<p>But you have all the tools now to specify exactly how you want it to work.
Now you have what JS is known for giving you a lot of: freedom.</p>
<pre class="hljs"><code>const Dog = dogProto | <span class="hljs-type">mixinPreM</span> (animalProto) | <span class="hljs-type">factory</span> | <span class="hljs-type">factoryProps</span> (dogProps)
const dog1 = Dog | <span class="hljs-type">create</span> ({})
dog1 | <span class="hljs-type">breathe</span> // 'huff'
const Dog = dogProto | <span class="hljs-type">mixinPreM</span> (animalProto) | <span class="hljs-type">factory</span> | <span class="hljs-type">factoryProps</span> (dogProps)
Dog.create ({}) | <span class="hljs-type">speak</span> // 'woof'</code></pre><p>We mixed the animal into the dog as a &#39;pre&#39; mixin, meaning that on name
conflicts, Dog&#39;s version will win. If we had used <code>mixinM</code> instead of
<code>mixinPreM</code>:</p>
<pre class="hljs"><code>const Dog = dogProto | <span class="hljs-type">mixinM</span> (animalProto) | <span class="hljs-type">factory</span> | <span class="hljs-type">factoryProps</span> (dogProps)
Dog | <span class="hljs-type">create</span> ({})
    | <span class="hljs-type">speak</span> // Error, this is Animal's version.</code></pre><p>Non-pre mixins are useful for orthogonal functionality -- something like
logging, for example.</p>
<p>You can add as many pre and post mixins as you like.</p>
<pre class="hljs"><code>dogProto |<span class="hljs-string"> mixinPreM (...) </span>|<span class="hljs-string"> ... </span>|<span class="hljs-string"> mixinM (...) </span>|<span class="hljs-string"> ... </span>|<span class="hljs-string"> factory</span></code></pre><p>Or use the &#39;N&#39; versions to provide an array:</p>
<pre class="hljs"><code>dogProto | <span class="hljs-type">mixinPreNM</span> ([a, b, c]) | <span class="hljs-type">mixinNM</span> ([d, e, f]) | <span class="hljs-type">factory</span></code></pre><p>Note the &#39;M&#39; marker on the mixin functions. This is to make clear that these
functions mutate the prototype object, which might be a bit surprising when
using this style. We do not provide non-M versions of the mixin functions,
because it&#39;s not obvious exactly what the semantics should be, as several
alternatives could be equally intuitive.</p>
<p>Should the prototype chain be flattened? Should it be discarded, leaving
only the own keys? Should it create a new object using and mutate it?</p>
<p>You can specify these behaviors explicitly:</p>
<pre class="hljs"><code>dogProto |<span class="hljs-string"> flattenPrototype </span>|<span class="hljs-string"> &lt;mixin functions ...&gt; </span>|
dogProto |<span class="hljs-string"> discardPrototype </span>|<span class="hljs-string"> &lt;mixin functions ...&gt; </span>|
dogProto |<span class="hljs-string"> Object.create    </span>|<span class="hljs-string"> &lt;mixin functions ...&gt; </span>|</code></pre><h2 id="٭-let-expressions-٭"><a class="header-link" href="#٭-let-expressions-٭"></a>٭ let expressions ٭</h2>
<p>You can consolidate a number of assignment statements into a single let
expression, and also limit the scope of the assignments in a way which is
easy to read. Code which is more expression-heavy can often be much easier
to follow at a glance &amp; refactor, especially considering that each statement
is a possible side-effect inducing timebomb.</p>
<pre class="hljs"><code><span class="hljs-comment">// --- convert a celsius value to both fahrenheit &amp; kelvin.</span>

const convertCelsius = (c) =&gt; letV (
  c / <span class="hljs-number">5</span> * <span class="hljs-number">9</span> + <span class="hljs-number">32</span>, <span class="hljs-comment">// fahrenheit</span>
  c - <span class="hljs-number">273</span>,   <span class="hljs-comment">// kelvin</span>
  (fah, kel) =&gt; [fah, kel],
)</code></pre><p><code>letV</code> takes an arbitrary number of values, and expects the last one to be a
function. It simply passes the values in order to the function.</p>
<p>There is an &#39;N&#39; form (<code>letVN</code>, which takes an array of values and one
function).</p>
<p>Far more useful is <code>lets</code> and <code>letS</code>. (Think &#39;let*&#39; in racket).</p>
<p>If we went the other way:</p>
<pre class="hljs"><code><span class="hljs-comment">// --- convert fahrenheit to celsius &amp; kelvin</span>

const convertFahrenheit = (f) =&gt; letV (
  (f - <span class="hljs-number">32</span>) / <span class="hljs-number">9</span> * <span class="hljs-number">5</span>,      <span class="hljs-comment">// celsius</span>
  (f - <span class="hljs-number">32</span>) / <span class="hljs-number">9</span> * <span class="hljs-number">5</span> + <span class="hljs-number">273</span> <span class="hljs-comment">// kelvin</span>
  (cel, kel) =&gt; [cel, kel],
)</code></pre><p>We see that we are wasting work. With <code>lets</code>, it would be:</p>
<pre class="hljs"><code><span class="hljs-comment">// --- convert fahrenheit to celsius &amp; kelvin</span>

<span class="hljs-keyword">const</span> convertFahrenheit = fah =&gt; lets (
  _ =&gt; (fah - <span class="hljs-number">32</span>) / <span class="hljs-number">9</span> * <span class="hljs-number">5</span>,    <span class="hljs-comment">// (1) celsius</span>
  (cel) =&gt; cel + <span class="hljs-number">273</span>,         <span class="hljs-comment">// (2) kelvin</span>
  (cel, kel) =&gt; [cel, kel],   <span class="hljs-comment">// (3) result</span>
)</code></pre><p><code>lets</code> expects each line to be a function. The first line is called with no
argument. The result (1) is passed as the argument to (2). (1) and the
result of (2) are passed as the arguments to (3), and so on. The result of
the last function is the result of the expression.</p>
<p>(For now, there can be up to 6 lines. See below for a generic version).</p>
<p>And of course there is a stick version of <code>lets</code> called <code>letS</code>. Think of the
&#39;S&#39; marker as &#39;stick enabled&#39; and the &#39;s&#39; as &#39;stick disabled&#39;. <code>letS</code>
expects a value to be piped in. <em>Note</em>: the &#39;S&#39; marker implies the &#39;N&#39;
marker: the arguments must be an array, or else it would be impossible to
curry.</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> convertFahrenheit = fah =&gt; fah | letS ([
  (fah) =&gt; (fah - <span class="hljs-number">32</span>) / <span class="hljs-number">9</span> * <span class="hljs-number">5</span>,     <span class="hljs-comment">// (1) celsius</span>
  (fah, cel) =&gt; cel + <span class="hljs-number">273</span>,         <span class="hljs-comment">// (2) kelvin</span>
  (fah, cel, kel) =&gt; [cel, kel]    <span class="hljs-comment">// (3) result</span>
])</code></pre><p>This wouldn&#39;t be the most natural use of <code>letS</code>, but it shows how it works:
Function (1) receives as a single argument the piped in value (<code>fah</code> in this case).
Function (2) receives <code>fah</code>, and the result of (1). (3) receives <code>fah</code>, the
results of (1) and (2), and so on. </p>
<p>By now we know that we can remove <code>fah =&gt; fah |</code> from the first line to
make it point-free, and we can use underscores to indicate ignored values:</p>
<pre class="hljs"><code>const convertFahrenheit = letS ([
  (fah) =&gt; (fah - <span class="hljs-number">32</span>) / <span class="hljs-number">9</span> * <span class="hljs-number">5</span>,
  <span class="hljs-function"><span class="hljs-params">(_, cel)</span> =&gt;</span> cel + <span class="hljs-number">273</span>,
  <span class="hljs-function"><span class="hljs-params">(_, cel, kel)</span> =&gt;</span> [cel, kel],
])</code></pre><p>As an exercise you could try to make the entire expression as point-free as
possible, at the expense of everyone&#39;s sanity:</p>
<pre class="hljs"><code><span class="hljs-keyword">import</span> { letS, <span class="hljs-keyword">minus</span>, divideBy, <span class="hljs-keyword">multiply</span>, add, arg1, list, tail, } <span class="hljs-keyword">from</span> <span class="hljs-string">'stick-js'</span>

const convertFahrenheit = letS ([
  <span class="hljs-keyword">minus</span> (<span class="hljs-number">32</span>) &gt;&gt; divideBy (<span class="hljs-number">9</span>) &gt;&gt; <span class="hljs-keyword">multiply</span> (<span class="hljs-number">5</span>),
  arg1 &gt;&gt; add (<span class="hljs-number">273</span>),
  list &gt;&gt; tail,
])

convertFahrenheit (<span class="hljs-number">86</span>) <span class="hljs-comment">// [30, 303]</span></code></pre><h2 id="٭-exceptions-٭-try/catch-٭"><a class="header-link" href="#٭-exceptions-٭-try/catch-٭"></a>٭ exceptions ٭ try/catch ٭</h2>
<pre class="hljs"><code><span class="hljs-keyword">import</span> { tryCatch, } <span class="hljs-keyword">from</span> <span class="hljs-string">'stick-js'</span>

const dubiousFunction = ...

dubiousFunction | tryCatch (
  <span class="hljs-regexp">//</span> --- <span class="hljs-literal">no</span> exception: `<span class="javascript">v</span>` <span class="hljs-keyword">is</span> the <span class="hljs-keyword">return</span> value <span class="hljs-keyword">of</span> `<span class="javascript">dubiousFunction</span>`
  (v) =&gt; ...,

  <span class="hljs-regexp">//</span> --- exception thrown: `<span class="javascript">e</span>` <span class="hljs-keyword">is</span> the exception
  (e) =&gt; e | decorateException (<span class="hljs-string">'Dubious function said:'</span>)
)</code></pre><p>Sometimes it&#39;s nice to rethrow an exception, with a string prefixed to it so
you can tell what went wrong:</p>
<pre class="hljs"><code>  (e) =&gt; e | decorateException (<span class="hljs-string">'Dubious function said:'</span>) | <span class="hljs-keyword">die</span>

<span class="hljs-keyword">const</span> throwError = reason =&gt; reason
  | <span class="hljs-keyword">exception</span> <span class="hljs-comment">// new Error (reason)</span>
  | raise     <span class="hljs-comment">// throw it</span>

<span class="hljs-keyword">const</span> throwError = reason =&gt; reason | (<span class="hljs-keyword">exception</span> &gt;&gt; raise)

<span class="hljs-comment">// `exception &gt;&gt; raise` is also known as `die`</span></code></pre><p>Note that this is illegal in JS, because <code>throw</code> is not an expression:</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> throwError = <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span> (reason)</code></pre><p>But we can trick it like this:</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> throwError = <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> reason | die

<span class="hljs-comment">// or just</span>
<span class="hljs-comment">// const error = die</span></code></pre><p>Now we can improve this common code:</p>
<pre class="hljs"><code><span class="hljs-keyword">let</span> answer
<span class="hljs-keyword">try</span> {
    answer = dubiousFunction ()
} <span class="hljs-keyword">catch</span> (e) {
    console.warn (e)
    answer = <span class="hljs-string">'bad news'</span>
}</code></pre><p>Like this:</p>
<pre class="hljs"><code>const answer = dubiousFunction | tryCatch (
  plus (<span class="hljs-number">10</span>),
  <span class="hljs-function"><span class="hljs-params">(e)</span> =&gt;</span> {
      e | decorateException (<span class="hljs-string">"That didn't go well"</span>)
        | <span class="hljs-built_in">console</span>.warn
      <span class="hljs-keyword">return</span> <span class="hljs-string">'bad news'</span>
  },
}</code></pre><p>Or perhaps:</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> answer = dubiousFunction | tryCatch (
  plus (<span class="hljs-number">10</span>),
  decorateException (<span class="hljs-string">"That didn't go well"</span>)
    &gt;&gt; tap (<span class="hljs-built_in">console</span>.warn)
    &gt;&gt; (<span class="hljs-string">'bad news'</span> | always)
)</code></pre><h2 id="٭-cond-٭"><a class="header-link" href="#٭-cond-٭"></a>٭ cond ٭</h2>
<pre class="hljs"><code><span class="hljs-keyword">import</span> {
  cond, condN, condS, guard, guardV, sprintf1, <span class="hljs-keyword">otherwise</span>,
} <span class="hljs-keyword">from</span> <span class="hljs-string">'stick-js'</span></code></pre><p>Naive form:</p>
<pre class="hljs"><code>cond (
  [<span class="hljs-number">3</span> === <span class="hljs-number">4</span>, _ =&gt; <span class="hljs-string">'strange'</span>],
  [<span class="hljs-number">3</span> === <span class="hljs-number">5</span>, _ =&gt; <span class="hljs-string">'even stranger'</span>],
  [<span class="hljs-keyword">null</span>, _ =&gt; <span class="hljs-string">'ok'</span>],
)</code></pre><p>An arbitrary number of lines can be provided.</p>
<p>With a stick idiom:</p>
<pre class="hljs"><code>cond (
  (<span class="hljs-keyword">_</span> =&gt; <span class="hljs-number">3</span> === <span class="hljs-number">4</span>) | <span class="hljs-type">guard</span> (<span class="hljs-keyword">_</span> =&gt; 'strange'),
  (<span class="hljs-keyword">_</span> =&gt; <span class="hljs-number">3</span> === <span class="hljs-number">5</span>) | <span class="hljs-type">guard</span> (<span class="hljs-keyword">_</span> =&gt; 'even stranger'),
  otherwise      | <span class="hljs-type">guard</span> (<span class="hljs-keyword">_</span> =&gt; 'ok'),
)</code></pre><p>If the guard functions return simple expressions, <code>guardV</code> can be more
convenient:</p>
<pre class="hljs"><code>cond (
  (<span class="hljs-name">_</span> =&gt; <span class="hljs-number">3</span> === <span class="hljs-number">4</span>) | guardV ('strange'),
  (_ =&gt; 3 === 5) | guardV ('even stranger'),
  otherwise      | guardV ('ok'),
)</code></pre><p>The most useful version is <code>condS</code>. Remember, &#39;S&#39; implies &#39;N&#39;, so give it an
array.</p>
<pre class="hljs"><code>const checkVal = val =&gt; val | <span class="hljs-type">condS</span> ([
  eq (<span class="hljs-number">4</span>)    | <span class="hljs-type">guard</span> (val =&gt; val | <span class="hljs-type">sprintf1</span> ('%s was <span class="hljs-number">4</span>')),
  lt (<span class="hljs-number">4</span>)    | <span class="hljs-type">guard</span> (val =&gt; val | <span class="hljs-type">sprintf1</span> ('%s was less than <span class="hljs-number">4</span>')),
  gt (<span class="hljs-number">4</span>)    | <span class="hljs-type">guard</span> (val =&gt; val | <span class="hljs-type">sprintf1</span> ('%s was more than <span class="hljs-number">4</span>')),
  otherwise | <span class="hljs-type">guardV</span> (<span class="hljs-string">"error, this shouldn't happen"</span>),
])</code></pre><p>Cleaning it up a bit, and inverting the parentheses in the test expressions:</p>
<pre class="hljs"><code>const checkVal = condS ([
  <span class="hljs-number">4</span> | eq    | guard  (<span class="hljs-name">sprintf1</span> ('%s was <span class="hljs-number">4</span>')),
  <span class="hljs-number">4</span> | lt    | guard  (<span class="hljs-name">sprintf1</span> ('%s was less than <span class="hljs-number">4</span>')),
  <span class="hljs-number">4</span> | gt    | guard  (<span class="hljs-name">sprintf1</span> ('%s was more than <span class="hljs-number">4</span>')),
  otherwise | guardV (<span class="hljs-string">"error, this shouldn't happen"</span>),
])</code></pre><p>Wut?! This does work, strange as it looks. Try it for yourself:</p>
<p>; [3, 4, 5]
| map (checkVal)
| join (&#39; | &#39;)
// 3 was less than 4 | 4 was 4 | 5 was more than 4</p>
<h2 id="٭-extended-regexes-٭"><a class="header-link" href="#٭-extended-regexes-٭"></a>٭ extended regexes ٭</h2>
<p>We provide regex functions which fit the idiom and mostly have an &#39;X&#39; in the
name (think /x if you know <code>perl</code>).</p>
<p>These are &#39;extended regexes&#39;, in which whitespace is ignored. Note that we
do not skip comments in the regex, only whitespace, even inside character
classes. Use <code>\s</code> if you really want to match on whitespace.</p>
<pre class="hljs"><code><span class="hljs-string">'egbert'</span> | xMatch (<span class="hljs-regexp">/ (eg) (..) [rs] /</span>)
<span class="hljs-regexp">//</span> [ <span class="hljs-string">'egber'</span>, <span class="hljs-string">'eg'</span>, <span class="hljs-string">'be'</span>, index: <span class="hljs-number">0</span>, input: <span class="hljs-string">'egbert'</span> ]

const vowels = []
const mapper = appendToM (vowels)
<span class="hljs-string">'egbert druppelvanger'</span> | xMatchGlobal (<span class="hljs-regexp">/ [ae] /</span>) (mapper)
vowels <span class="hljs-regexp">//</span> [ <span class="hljs-string">'e'</span>, <span class="hljs-string">'e'</span>, <span class="hljs-string">'e'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'e'</span> ]

<span class="hljs-string">'egbert'</span> | xMatchStr (<span class="hljs-string">' (eg) (..) [rs] '</span>)
<span class="hljs-regexp">//</span> [ <span class="hljs-string">'egber'</span>, <span class="hljs-string">'eg'</span>, <span class="hljs-string">'be'</span>, index: <span class="hljs-number">0</span>, input: <span class="hljs-string">'egbert'</span> ]

<span class="hljs-string">'egbert\ndruppelvanger'</span> | xMatchStrFlags (<span class="hljs-string">' ^ d '</span>) (<span class="hljs-string">'s'</span>)
<span class="hljs-regexp">//</span> null

<span class="hljs-string">'egbert\ndruppelvanger'</span> | xMatchStrFlags (<span class="hljs-string">' ^ d '</span>) (<span class="hljs-string">'m'</span>)
<span class="hljs-regexp">//</span> [ <span class="hljs-string">'d'</span>, index: <span class="hljs-number">7</span>, input: <span class="hljs-string">'egbert\ndruppelvanger'</span> ]

const toUpper = dot (<span class="hljs-string">'toUpperCase'</span>)

const ifReplaceVowels = ifXReplace (<span class="hljs-regexp">/ ([aeiou]) /</span>) (<span class="hljs-string">'x'</span>)
<span class="hljs-string">'egbert'</span> | ifReplaceVowels (toUpper) (<span class="hljs-string">'bad'</span> | always)
<span class="hljs-regexp">//</span> XGBXRT

const ifReplaceVowelsGlobal = ifXReplace (<span class="hljs-regexp">/ ([aeiou]) /g</span>) (<span class="hljs-string">'x'</span>)
<span class="hljs-string">'egbert'</span> | ifReplaceVowelsGlobal (toUpper) (<span class="hljs-string">'bad'</span> | always)
<span class="hljs-regexp">//</span> XGBXRT

const ifReplaceVowelsGlobalAlt = ifXReplaceStrFlags (<span class="hljs-string">' ([aeiou]) '</span>) (<span class="hljs-string">'g'</span>) (<span class="hljs-string">'x'</span>)
<span class="hljs-string">'egbert'</span> | ifReplaceVowelsGlobalAlt (toUpper) (<span class="hljs-string">'bad'</span> | always)
<span class="hljs-regexp">//</span> XGBXRT</code></pre><h2 id="٭-merging-٭"><a class="header-link" href="#٭-merging-٭"></a>٭ merging ٭</h2>
<p>We provide 8 basic merge functions, corresponding to all combinations of
three binary choices:</p>
<ol class="list">
<li><em>to</em> vs. <em>from</em>           (order of arguments)</li>
<li>&#39;<em>own</em>&#39; vs. &#39;<em>in</em>&#39;        (prototype values)</li>
<li><em>mutable</em> vs. <em>immutable</em> (whether to clone the target first)</li>
</ol>
<p>There are a few conventions to keep in mind when trying to understand the
semantics. To vs. from is just a question of switching the arguments, so we
don&#39;t need to discuss it, but the other 4 combinations have some caveats.</p>
<pre class="hljs"><code><span class="hljs-selector-tag">tgt</span> | <span class="hljs-selector-tag">merge</span>    (src) <span class="hljs-comment">// (1) own, immutable</span>
<span class="hljs-selector-tag">tgt</span> | <span class="hljs-selector-tag">mergeIn</span>  (src) <span class="hljs-comment">// (2) in,  immutable</span>
<span class="hljs-selector-tag">tgt</span> | <span class="hljs-selector-tag">mergeM</span>   (src) <span class="hljs-comment">// (3) own, mutable</span>
<span class="hljs-selector-tag">tgt</span> | <span class="hljs-selector-tag">mergeInM</span> (src) <span class="hljs-comment">// (4) in,  mutable</span>

<span class="hljs-comment">// mergeTo, mergeInTo, mergeToM, mergeInToM: 'to' forms</span></code></pre><p>In the immutable cases, a clone is made of the target before merging. You
must keep in mind whether the clone will use only &#39;own&#39; properties or also
the prototype (&#39;in&#39;) properties. Case (1) corresponds to &#39;own&#39; and case (2)
to &#39;in&#39;.</p>
<p>No matter which it is, all copied properties will become own properties of
the clone.*</p>
<p>Then, properties are copied over from the source: only own properties in
case (1), also &#39;in&#39; properties in case (2).</p>
<p>The rule to remember in the immutable case is: &#39;own&#39; merges with &#39;own&#39; and
&#39;in&#39; with &#39;in&#39;.</p>
<p>In the mutable case, the target object is not cloned nor altered in any way,
except of course that properties are copied in from the source. In
particular this means that the &#39;own&#39; in case (3) only applies to the source:
the prototype chain of the target will not be flattened or discarded or
altered at all.</p>
<p>The rule to remember in the mutable case is: the target is never altered in
any way, besides having properties copied in. So the &#39;own&#39; / &#39;in&#39;
distinction only applies to the source.</p>
<p>We feel that these conventions are the most straightforward and lead to
easily inferrable behavior.</p>
<p>In all cases, we are only ever talking about enumerable properties.</p>
<p>* This is good enough for most styles of functional programming in JS, many
of which don&#39;t even bother with the distinction. People often expect
shallow, cheap objects when programming this way. If you absolutely must
preserve the prototype chain intact, you&#39;ll have to find a way to clone it
yourself, then use the &#39;M&#39; versions of our merge functions on your cloned
object. You might also get away with using <code>Object.create</code> on it first,
which will of course create one more link in the prototype chain.</p>
<h2 id="٭-frontend-stuff-٭"><a class="header-link" href="#٭-frontend-stuff-٭"></a>٭ frontend stuff ٭</h2>
<pre class="hljs"><code><span class="hljs-keyword">import</span> { path, prop, whenTrue, always, } <span class="hljs-keyword">from</span> <span class="hljs-string">'stick-js'</span></code></pre><p>If you use react/redux, perhaps with saga, chances are your modules end in
something like this:</p>
<pre class="hljs"><code>const withConnect = connect(<span class="hljs-name">mapStateToProps</span>, mapDispatchToProps)<span class="hljs-comment">;</span>
const withReducer = injectReducer({ key: 'home', reducer })<span class="hljs-comment">;</span>
const withSaga = injectSaga({ key: 'home', saga })<span class="hljs-comment">;</span>

export default compose(
  <span class="hljs-name">withReducer</span>,
  withSaga,
  withConnect,
)(<span class="hljs-name">HomePage</span>)<span class="hljs-comment">;</span></code></pre><p>We should see by now that this composing of functions, invoked upon a single
value, is exactly our pipe pattern. So why not:</p>
<pre class="hljs"><code><span class="hljs-keyword">export</span> <span class="hljs-built_in">default</span> HomePage
  | <span class="hljs-built_in">connect</span>       (mapStateToProps, mapDispatchToProps)
  | injectSaga    ({ key: <span class="hljs-string">'home'</span>, saga, })
  | injectReducer ({ key: <span class="hljs-string">'home'</span>, reducer, })</code></pre><p>And maybe you call actions using a structure like:</p>
<pre class="hljs"><code><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mapDispatchToProps</span>(<span class="hljs-params">dispatch</span>) </span>{
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">onChangeUsername</span>: <span class="hljs-function">(<span class="hljs-params">evt</span>) =&gt;</span> dispatch(changeUsername(evt.target.value)),
  };
};</code></pre><p>Why not:</p>
<pre class="hljs"><code><span class="hljs-keyword">export</span> const mapDispatchToProps = <span class="hljs-function"><span class="hljs-params">(dispatch)</span> =&gt;</span> ({
  onChangeUsername: path ([<span class="hljs-string">'target'</span>, <span class="hljs-string">'value'</span>] &gt;&gt; changeUsername &gt;&gt; dispatch,
})</code></pre><p>Try it yourself and see :D</p>
<p>If you use <code>styled components</code>, perhaps you pass optional props in. Checking
for the presence of the props can be annoying, so how about:</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> SomeElementS = styled.div<span class="hljs-string">`
  top: 5%;
  left: 5%;
  <span class="hljs-subst">${ prop (<span class="hljs-string">'width'</span>)  &gt;&gt; whenOk   (sprintf1 (<span class="hljs-string">'width: %spx;'</span>)) }</span>
  <span class="hljs-subst">${ prop (<span class="hljs-string">'height'</span>) &gt;&gt; whenOk   (sprintf1 (<span class="hljs-string">'height: %spx;'</span>)) }</span>
  <span class="hljs-subst">${ prop (<span class="hljs-string">'error'</span>)  &gt;&gt; whenTrue (<span class="hljs-string">'color: red;'</span> | always) }</span>
`</span>

&lt;SomeElementS width=<span class="hljs-string">'100%'</span> error={<span class="hljs-literal">true</span>} /&gt;</code></pre><p>If you use <code>saga</code>, perhaps you have something like this:</p>
<pre class="hljs"><code><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">getRepos</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> username = <span class="hljs-keyword">yield</span> select(makeSelectUsername());
  <span class="hljs-keyword">const</span> requestURL = <span class="hljs-string">`https://api.github.com/users/<span class="hljs-subst">${username}</span>/repos`</span>;

  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> repos = <span class="hljs-keyword">yield</span> call(request, requestURL);
    <span class="hljs-keyword">yield</span> put(reposLoaded(repos, username));
  } <span class="hljs-keyword">catch</span> (err) {
    <span class="hljs-keyword">yield</span> put(repoLoadingError(err));
  }
}</code></pre><p>How about this:</p>
<pre class="hljs"><code><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">getRepos</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> username = <span class="hljs-keyword">yield</span> makeSelectUsername () | select
  <span class="hljs-keyword">const</span> requestURL = username | sprintf1 (<span class="hljs-string">'https://api.github.com/users/%s/repos'</span>)
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> repos = <span class="hljs-keyword">yield</span> call (request, requestURL)
    reposLoaded (repos, username) | reposLoaded | put
  } <span class="hljs-keyword">catch</span> (err) {
    <span class="hljs-keyword">yield</span> err | repoLoadingError | put
  }
}</code></pre><p>Try it yourself and see :D Note that we can&#39;t use our <code>tryCatch</code> function
here, because of the <code>yield</code> in the <code>catch</code> clause.</p>
<p>If you use <code>reselect</code>, this is fine:</p>
<pre class="hljs"><code>const selectHome = <span class="hljs-function"><span class="hljs-params">(state)</span> =&gt;</span> state.get(<span class="hljs-string">'home'</span>);
const makeSelectUsername = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> createSelector(
  selectHome,
  <span class="hljs-function"><span class="hljs-params">(homeState)</span> =&gt;</span> homeState.get(<span class="hljs-string">'username'</span>)
);</code></pre><p>But how about this:</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> <span class="hljs-keyword">get</span> = dot1 (<span class="hljs-string">'get'</span>)

<span class="hljs-keyword">const</span> selectHome = <span class="hljs-keyword">get</span> (<span class="hljs-string">'home'</span>)
<span class="hljs-keyword">const</span> makeSelectUsername = () =&gt; createSelector (
  selectHome,
  <span class="hljs-keyword">get</span> (<span class="hljs-string">'username'</span>),
)</code></pre><p>When composing selectors, something like this works nicely to make sure the
one being composed is valid:</p>
<pre class="hljs"><code><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> makeSelectBooks = _ =&gt; createSelector (
  selectHome,
  <span class="hljs-keyword">get</span> (<span class="hljs-string">'books'</span>),
)

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> makeSelectBookTitles = _ =&gt; createSelector (
  makeSelectBooks (),
  <span class="hljs-string">'titles'</span> | <span class="hljs-keyword">get</span> | whenOk,
)</code></pre><p>The author uses stick idioms to slay a common front-end pattern. When you&#39;re
fetching your list of todos, the list should be <code>undefined</code> when it hasn&#39;t
been set yet, and empty only if it has been fetched and really is empty.
This makes testing easier, avoids weird flickers, lets you show a spinner,
etc. It does introduce an extra condition you need to test for in your code,
but we can handle this nicely:</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> ListS = styled.div<span class="hljs-string">`
  min-height: 150px;
`</span>

<span class="hljs-keyword">const</span> List = <span class="hljs-function">(<span class="hljs-params">{ children }</span>) =&gt;</span> &lt;ListS&gt;
  {children | ifOk (identity) (spinner)}
&lt;<span class="hljs-regexp">/ListS&gt;</span></code></pre><h2 id="٭-backend-stuff-٭"><a class="header-link" href="#٭-backend-stuff-٭"></a>٭ backend stuff ٭</h2>
<p>When you&#39;re using a framework like Express, you have the well-known <code>app</code>
object that you carry around everywhere. It just so happens that nearly all
methods of <code>app</code> return <code>this</code>, so that chaining works in the familiar way:</p>
<pre class="hljs"><code>app
<span class="hljs-selector-class">.use</span> (...)
<span class="hljs-selector-class">.all</span> (...)
<span class="hljs-selector-class">.post</span> (<span class="hljs-string">'/endpoint1'</span>, ((req, res) =&gt; ...))
<span class="hljs-selector-class">.patch</span> (<span class="hljs-string">'/endpoint2'</span>, ((req, res) =&gt; ...))
<span class="hljs-selector-class">.get</span> (<span class="hljs-string">'/endpoint3'</span>, ((req, res) =&gt; ...))
...
<span class="hljs-selector-class">.listen</span> (config<span class="hljs-selector-class">.port</span>, ...)</code></pre><p>But there are cases when the makers were not so thoughtful, or when you
simply don&#39;t know (or don&#39;t care) what a function or method returns. The
pipe will free you from the limitations of the dot, and allow you to compose
your own fluid interfaces. We&#39;ll use Express here to prove that it works.
See the raindrops example for how you might use this with WebGL, and there
are many other places this can be used.</p>
<pre class="hljs"><code><span class="hljs-keyword">import</span> { side1, side2, list, appendTo, } <span class="hljs-keyword">from</span> <span class="hljs-string">'stick-js'</span>
<span class="hljs-keyword">import</span> { fromPairs, } <span class="hljs-keyword">from</span> <span class="hljs-string">'ramda'</span>

<span class="hljs-keyword">const</span> get      = side2 (<span class="hljs-string">'get'</span>)
<span class="hljs-keyword">const</span> post     = side2 (<span class="hljs-string">'post'</span>)
<span class="hljs-keyword">const</span> patch    = side2 (<span class="hljs-string">'patch'</span>)
<span class="hljs-keyword">const</span> use      = side1 (<span class="hljs-string">'use'</span>)
<span class="hljs-keyword">const</span> all      = side2 (<span class="hljs-string">'all'</span>)
<span class="hljs-keyword">const</span> send     = side1 (<span class="hljs-string">'send'</span>)
<span class="hljs-keyword">const</span> status   = side1 (<span class="hljs-string">'status'</span>)
<span class="hljs-keyword">const</span> listen   = side2 (<span class="hljs-string">'listen'</span>)
<span class="hljs-keyword">const</span> sendJSON = side1 (<span class="hljs-string">'json'</span>)

<span class="hljs-keyword">const</span> sendStatus = <span class="hljs-function"><span class="hljs-params">code</span> =&gt;</span> data =&gt; status (code) &gt;&gt; sendJSON (data)
<span class="hljs-keyword">const</span> msg = appendTo ([<span class="hljs-string">'msg'</span>]) &gt;&gt; list &gt;&gt; fromPairs

app | use (bodyParser.json())
    | all (<span class="hljs-string">'*'</span>, (req, res, next) =&gt; {
      ...
        next ()
    })

    | post (<span class="hljs-string">'/endpoint1'</span>, (<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {
      ...
      res | sendStatus (<span class="hljs-number">500</span>) (<span class="hljs-string">'Server error'</span> | msg)
    }))

    | patch (<span class="hljs-string">'/endpoint2'</span>, (<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {
      ...
      res | sendStatus (<span class="hljs-number">200</span>) ({ results, })
    }))

    ...

    | get (<span class="hljs-string">'/endpoint3'</span>, (<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> ...))

    | listen (config.port) (...)</code></pre><h1 id="performance"><a class="header-link" href="#performance"></a>performance</h1>
<p>Stick is fast. (@todo link benchmark)</p>
<p>Though it initially depended on Ramda, we have decided to eliminate that
dependency by reimplementing many of the functions. While profiling the
WebGL example we found that even trivial functions like <code>R.flip</code> and <code>R.tap</code>
are surprisingly expensive.</p>
<p>This really only becomes an issue in critical loops with millions of
iterations per second.</p>
<p>It is true that <code>a | b</code> compiles to three function calls, whereas <code>b (a)</code> is
only one. But this is almost certainly not going to affect your app. Your JS
runtime can call <em>a lot</em> of functions per millisecond.</p>
<p>Nonetheless you are encouraged to mix and match our functions with whichever
functional libraries you like -- Ramda, Lodash/FP, or anything else, as it
suits you.</p>
<pre class="hljs"><code><span class="hljs-keyword">import</span> { map, } <span class="hljs-keyword">from</span> <span class="hljs-string">'ramda'</span>
<span class="hljs-keyword">import</span> { filter, } <span class="hljs-keyword">from</span> <span class="hljs-string">'lodash/fp'</span>
<span class="hljs-keyword">import</span> { ifPredicate, } <span class="hljs-keyword">from</span> <span class="hljs-string">'stick-js'</span></code></pre><p>The stick idiom will still work, as long as the functions are curried and
data-last.</p>
<p>Furthermore Ramda is probably perfectly fine for your app, and its functions
often provide type-checking and error messages (we don&#39;t), and many of their
functions are more sophisticated. <code>R.map</code> works on functors and
transformers, for example -- ours doesn&#39;t.</p>
<p>And, it is our belief that if you are already using the <code>flow</code> pattern in
Lodash/FP or the <code>pipe</code> function in Ramda, that it will really be a
no-brainer to overload the operator and keep everything else the same.</p>
<pre class="hljs"><code><span class="hljs-symbol">_</span>.flow (
  <span class="hljs-symbol">_</span>.<span class="hljs-built_in">split</span> (' '),
  <span class="hljs-symbol">_</span>.<span class="hljs-built_in">map</span> (capitaliseFirstLetter),
  <span class="hljs-symbol">_</span>.<span class="hljs-built_in">join</span> (' '),
) (myData)

// -&gt;
myData
| <span class="hljs-symbol">_</span>.<span class="hljs-built_in">split</span> (' '),
| <span class="hljs-symbol">_</span>.<span class="hljs-built_in">map</span> (capitaliseFirstLetter),
| <span class="hljs-symbol">_</span>.<span class="hljs-built_in">join</span> (' ')</code></pre><p>merge benchmark: manual / index / ramda</p>
<h2 id="working-with-functors:-maybe"><a class="header-link" href="#working-with-functors:-maybe"></a>Working with functors: Maybe</h2>
<h3 id="(or-how-to-forget-about-`null`-and-`undefined`-for-a-while)"><a class="header-link" href="#(or-how-to-forget-about-`null`-and-`undefined`-for-a-while)"></a>(or how to forget about <code>null</code> and <code>undefined</code> for a while)</h3>
<p>Here is an example showing how you can deal with failure paths, using the
<code>Maybe</code> functor from
<a href="https://github.com/puffnfresh/bilby.js">bilby</a> by @puffnfresh. In this toy
example, we start with a French word, then:</p>
<ol class="list">
<li><p>look up a translation (mocked in a table);</p>
<p> <em>failure path: the translation might not exist</em></p>
</li>
<li><p>look up a corresponding &#39;count&#39; value (also mocked in a table);</p>
<p> <em>failure path: the count might not exist</em></p>
</li>
<li><p>divide this number into 10 for some reason;</p>
<p> <em>failure path: the number might be 0</em></p>
</li>
</ol>
<p>&nbsp;</p>
<pre class="hljs"><code><span class="hljs-keyword">import</span> { some <span class="hljs-keyword">as</span> Just, none <span class="hljs-keyword">as</span> Nothing, } <span class="hljs-keyword">from</span> <span class="hljs-string">'bilby'</span>

<span class="hljs-keyword">const</span> toMaybe = <span class="hljs-function"><span class="hljs-params">o</span> =&gt;</span> o | ifOk (
  Just,
  Nothing | always,
)

<span class="hljs-keyword">const</span> flatMap = dot1 (<span class="hljs-string">'flatMap'</span>)
<span class="hljs-keyword">const</span> fold    = dot2 (<span class="hljs-string">'fold'</span>)

<span class="hljs-keyword">const</span> translations = {
  <span class="hljs-attr">rouge</span>: <span class="hljs-string">'red'</span>,
  <span class="hljs-attr">bleu</span>: <span class="hljs-string">'blue'</span>,
  <span class="hljs-attr">vert</span>: <span class="hljs-string">'green'</span>,
  <span class="hljs-comment">// blanc missing</span>
}

<span class="hljs-keyword">const</span> count = {
  <span class="hljs-attr">red</span>: <span class="hljs-number">5</span>,
  <span class="hljs-attr">blue</span>: <span class="hljs-number">0</span>,
  <span class="hljs-comment">// green missing</span>
}

<span class="hljs-keyword">const</span> formatAnswer = <span class="hljs-function"><span class="hljs-params">input</span> =&gt;</span> answer =&gt; [input | yellow, answer] | sprintfN (<span class="hljs-string">'%s → %s'</span>)

<span class="hljs-keyword">const</span> go = <span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span>
  [<span class="hljs-string">'rouge'</span>, <span class="hljs-string">'bleu'</span>, <span class="hljs-string">'vert'</span>, <span class="hljs-string">'blanc'</span>]
  | map (doit)
  | tap (map (log))

<span class="hljs-keyword">const</span> doit = <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x | calculate | formatAnswer (x)

<span class="hljs-keyword">const</span> calculate = <span class="hljs-function"><span class="hljs-params">french</span> =&gt;</span> doLookup (french)
  | fold (
    <span class="hljs-function"><span class="hljs-params">answer</span> =&gt;</span> answer + <span class="hljs-string">' '</span> + green (<span class="hljs-string">'✔'</span>),
    red (<span class="hljs-string">'✘'</span>) | always,
  )

<span class="hljs-keyword">const</span> doLookup = <span class="hljs-function"><span class="hljs-params">french</span> =&gt;</span> french
  | getTranslation
  | flatMap (getCount)
  | flatMap (getQuotient)

<span class="hljs-keyword">const</span> getTranslation = <span class="hljs-function"><span class="hljs-params">french</span> =&gt;</span> translations [french] | toMaybe

<span class="hljs-keyword">const</span> getCount = <span class="hljs-function"><span class="hljs-params">english</span> =&gt;</span> count [english] | toMaybe

<span class="hljs-keyword">const</span> getQuotient = condS ([
  <span class="hljs-number">0</span> | eq    | guard (<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> Nothing),
  otherwise | guard (<span class="hljs-function"><span class="hljs-params">cnt</span> =&gt;</span> Just (<span class="hljs-number">10</span> / cnt)),
])

go ()</code></pre><p class="img-container"><img src="readme-assets/maybe.jpg" alt="maybe.jpg"></p>
<h2 id="working-with-functors:-either"><a class="header-link" href="#working-with-functors:-either"></a>Working with functors: Either</h2>
<p>The above example, using <code>bilby</code>&#39;s <code>Either</code> functor instead of <code>Maybe</code>, and a more point-free style.</p>
<p>The advantage of <code>Either</code> is that in addition to <code>flatMap</code> taking care of
the failure path, you can also see why it failed. By convention the &#39;Left&#39;
branch is considered a failure, and a string stored in &#39;Left&#39; represents the
reason.</p>
<pre class="hljs"><code><span class="hljs-keyword">import</span> { left <span class="hljs-keyword">as</span> Left, right <span class="hljs-keyword">as</span> Right, } <span class="hljs-keyword">from</span> <span class="hljs-string">'bilby'</span>

<span class="hljs-keyword">const</span> toEither = <span class="hljs-function"><span class="hljs-params">l</span> =&gt;</span> ifOk (
  Right,
  l | Left | always,
)

<span class="hljs-keyword">const</span> flatMap   = dot1 (<span class="hljs-string">'flatMap'</span>)
<span class="hljs-keyword">const</span> fold      = dot2 (<span class="hljs-string">'fold'</span>)
<span class="hljs-keyword">const</span> arrowSnd  = <span class="hljs-function"><span class="hljs-params">f</span> =&gt;</span> ([a, b]) =&gt; [a, b | f]
<span class="hljs-keyword">const</span> foldArrow = <span class="hljs-function"><span class="hljs-params">f</span> =&gt;</span> ([a, b]) =&gt; f (a, b)

<span class="hljs-keyword">const</span> translations = {
  <span class="hljs-attr">rouge</span>: <span class="hljs-string">'red'</span>,
  <span class="hljs-attr">bleu</span>: <span class="hljs-string">'blue'</span>,
  <span class="hljs-attr">vert</span>: <span class="hljs-string">'green'</span>,
  <span class="hljs-comment">// blanc missing</span>
}

<span class="hljs-keyword">const</span> count = {
  <span class="hljs-attr">red</span>: <span class="hljs-number">5</span>,
  <span class="hljs-attr">blue</span>: <span class="hljs-number">0</span>,
  <span class="hljs-comment">// green missing</span>
}

<span class="hljs-keyword">const</span> formatAnswer   = asterisk2 (yellow, id) &gt;&gt; sprintfN (<span class="hljs-string">'%s → %s'</span>)

<span class="hljs-keyword">const</span> getTranslation = propOf (translations) &gt;&gt; toEither (<span class="hljs-string">'no translation'</span>)
<span class="hljs-keyword">const</span> getCount       = propOf (count)        &gt;&gt; toEither (<span class="hljs-string">'no count'</span>)

<span class="hljs-keyword">const</span> getQuotient = condS ([
  <span class="hljs-number">0</span> | eq    | guardV (<span class="hljs-string">'count was zero'</span> | Left),
  otherwise | guard  (divideInto (<span class="hljs-number">10</span>) &gt;&gt; Right),
])

<span class="hljs-keyword">const</span> doLookup = getTranslation
  &gt;&gt; flatMap (getCount)
  &gt;&gt; flatMap (getQuotient)

<span class="hljs-keyword">const</span> calculate = doLookup &gt;&gt; fold (
  prependTo ([<span class="hljs-string">'✘'</span> | red])   &gt;&gt; sprintfN (<span class="hljs-string">'%s %s'</span>),
  prependTo ([<span class="hljs-string">'✔'</span> | green]) &gt;&gt; sprintfN (<span class="hljs-string">'%s %s'</span>),
)

<span class="hljs-keyword">const</span> doit = timesV (<span class="hljs-number">2</span>)
  &gt;&gt; arrowSnd (calculate)
  &gt;&gt; foldArrow (formatAnswer)

<span class="hljs-keyword">const</span> go = <span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span>
  [<span class="hljs-string">'rouge'</span>, <span class="hljs-string">'bleu'</span>, <span class="hljs-string">'vert'</span>, <span class="hljs-string">'blanc'</span>]
  | map (doit)
  | tap (map (log))

go ()</code></pre><p class="img-container"><img src="readme-assets/either.jpg" alt="either.jpg"></p>
<h2 id="٭-functors-/-flatmap-٭-explanation"><a class="header-link" href="#٭-functors-/-flatmap-٭-explanation"></a>٭ Functors / flatMap ٭ explanation</h2>
<p>Think of the <code>Either</code> functor as a value in a box, where the box is either a
&#39;Left&#39; box, meaning something went wrong, or a &#39;Right&#39; box, meaning things
are going well.</p>
<p>If you have a value like <code>Right (2)</code></p>
<p>and you pipe it to <code>flatMap</code>:</p>
<pre class="hljs"><code>const <span class="hljs-built_in">double</span> = x =&gt; x * <span class="hljs-number">2</span>
const r = <span class="hljs-keyword">Right</span> (<span class="hljs-number">2</span>)
r | <span class="hljs-type">flatMap</span> (<span class="hljs-built_in">double</span>) // <span class="hljs-keyword">Right</span> (<span class="hljs-number">4</span>)</code></pre><p>Then the resulting value is is <code>Right (4)</code>, because <code>flatMap</code> &#39;peeks&#39; inside
the box, manipulates the value inside, and wraps it up again in the box.</p>
<p>But it your value was a &#39;Left&#39; like <code>Left (&#39;bad news&#39;)</code></p>
<p>and you pipe it to <code>flatMap</code>:</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> <span class="hljs-built_in">double</span> = x =&gt; x * <span class="hljs-number">2</span>
<span class="hljs-keyword">const</span> l = Left (<span class="hljs-string">'bad news'</span>)
l | flatMap (<span class="hljs-built_in">double</span>) <span class="hljs-comment">// Left ('bad news')</span></code></pre><p>The result is the same as the input, because when <code>flatMap</code> sees a &#39;Left&#39;
value, it doesn&#39;t bother to unwrap the box or do anything with it. It just
passes the value straight through.</p>
<p>At the end of the chain, we are left with an <code>Either</code> which either contains
a <code>Left</code> or a <code>Right</code>; or in the case of <code>Maybe</code>, a <code>Just</code> or a <code>Nothing</code>.
Now we use <code>bilby</code>&#39;s <code>fold</code> function to resolve it:</p>
<pre class="hljs"><code>myEither | fold (
  <span class="hljs-comment">// --- the 'left' case, something went wrong.</span>
  <span class="hljs-comment">// the first %s will be the reason and the second will be a red cross.</span>
  prependTo ([<span class="hljs-string">'✘'</span> | <span class="hljs-built_in">red</span>])   &gt;&gt; sprintfN (<span class="hljs-string">'%s %s'</span>),

  <span class="hljs-comment">// --- the 'right' case, good to go.</span>
  <span class="hljs-comment">// the first %s will be the answer and the second will be a green check.</span>
  prependTo ([<span class="hljs-string">'✔'</span> | <span class="hljs-built_in">green</span>]) &gt;&gt; sprintfN (<span class="hljs-string">'%s %s'</span>),
)</code></pre><p>JS programmers have seen this thousands of times before …</p>
<pre class="hljs"><code>axios<span class="hljs-selector-class">.get</span> (<span class="hljs-string">'/some/api'</span>)
<span class="hljs-selector-class">.then</span> (response =&gt; ...)</code></pre><p>In a promise chain, <code>then</code> will only kick in if the promise returned by
<code>axios.get</code> resolves. If it rejects then the whole then line is skipped. It&#39;s
the same idea.</p>
<h2 id="abstract-data-types"><a class="header-link" href="#abstract-data-types"></a>Abstract data types</h2>
<p>Abstract data types can help eliminate an entire class of bugs, by making
impossible states unrepresentable.</p>
<p>Imagine you have something like a traffic light, which at any moment can be
either red, yellow, green, or broken. (Or a download, which can be in
progress, stopped, completed, failed, ...) You can use a normal object to
represent these sorts of things, but you might find yourself carrying around
properties like &#39;error&#39; and &#39;state&#39; and &#39;type&#39; and so on using a lot of <code>if</code>
statements to check for illegal states.</p>
<p>Another way is to model the data using ADTs, build the states, then branch
using a &#39;catamorphism&#39; to resolve the states when you&#39;re ready.</p>
<p>In this example we use <a href="https://github.com/fantasyland/daggy">daggy</a> by
@fantasyland to create an ADT representing various kinds of numerical
sequences.</p>
<p>In Haskell our declaration would be:</p>
<pre class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Sequence</span> = <span class="hljs-type">ArithmeticSequence</span> <span class="hljs-type">Int</span> <span class="hljs-comment">-- y = nx</span></span>
              | <span class="hljs-type">GeometricSequence</span> <span class="hljs-type">Int</span>  <span class="hljs-comment">-- y = c ** x</span>
              | <span class="hljs-type">IrregularSequence</span>
              | <span class="hljs-type">ErrorSequence</span> <span class="hljs-type">String</span>   <span class="hljs-comment">-- error with a reason</span></code></pre><p>In (pseudo-)Java maybe something like:</p>
<pre class="hljs"><code><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sequence</span> </span>{}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArithmeticSequence</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sequence</span> </span>{
  public <span class="hljs-type">ArithmeticSequence</span>(int n) {} <span class="hljs-comment">// y = nx</span>
}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GeometricSequence</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sequence</span> </span>{
  public <span class="hljs-type">GeometricSequence</span>(int c) {} <span class="hljs-comment">// y = c ** x</span>
}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IrregularSequence</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sequence</span> </span>{
  public <span class="hljs-type">IrregularSequence</span>() {}
}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ErrorSequence</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sequence</span> </span>{
  public <span class="hljs-type">ErrorSequence</span>(<span class="hljs-type">String</span> reason) {}
}</code></pre><p>Using stick idioms and <code>daggy</code>:</p>
<pre class="hljs"><code><span class="hljs-comment">// --- types.js</span>

<span class="hljs-keyword">import</span> daggy <span class="hljs-keyword">from</span> <span class="hljs-string">'daggy'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> Sequence = daggy.taggedSum (<span class="hljs-string">'Sequence'</span>, {
  <span class="hljs-attr">ArithmeticSequence</span>: [<span class="hljs-string">'n'</span>],
  <span class="hljs-attr">GeometricSequence</span>: [<span class="hljs-string">'c'</span>],
  <span class="hljs-attr">IrregularSequence</span>: [],
  <span class="hljs-attr">ErrorSequence</span>: [<span class="hljs-string">'reason'</span>],
})

<span class="hljs-keyword">const</span> { ArithmeticSequence, GeometricSequence, IrregularSequence, ErrorSequence, } = Sequence

<span class="hljs-keyword">export</span> { ArithmeticSequence, GeometricSequence, IrregularSequence, ErrorSequence, }

<span class="hljs-comment">// --- sequence.js</span>

<span class="hljs-keyword">const</span> testReduce = <span class="hljs-function"><span class="hljs-params">f</span> =&gt;</span> n =&gt; <span class="hljs-function">(<span class="hljs-params">acc, x</span>) =&gt;</span> f (acc, x) === n ? x : <span class="hljs-literal">null</span>
<span class="hljs-keyword">const</span> testReduceArithmetic = minus    | testReduce
<span class="hljs-keyword">const</span> testReduceGeometric  = divideBy | testReduce

<span class="hljs-keyword">const</span> testSequence = <span class="hljs-function"><span class="hljs-params">g</span> =&gt;</span> f =&gt; <span class="hljs-function">(<span class="hljs-params">[a, b, ...rest]</span>) =&gt;</span> lets (
  <span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> b | g (a),
  n =&gt; rest | reduceAbort (n | f) (b) (<span class="hljs-literal">null</span>),
  (n, reduced) =&gt; reduced === <span class="hljs-literal">null</span> ? <span class="hljs-literal">false</span> : n,
)

<span class="hljs-keyword">const</span> containsNull = <span class="hljs-literal">null</span> | contains

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> isArithmetic = testReduceArithmetic | testSequence (minus)
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> isGeometric  = testReduceGeometric  | testSequence (divideBy)
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> isError      = <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> containsNull (x) ? <span class="hljs-string">'contains null'</span> : <span class="hljs-literal">false</span>

<span class="hljs-comment">// --- util.js</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> cata = dot1 (<span class="hljs-string">'cata'</span>)

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> repeatChar = <span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> timesV (n) &gt;&gt; join (<span class="hljs-string">''</span>)
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> pad = <span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> str =&gt; (n - str.length) | condS ([
  <span class="hljs-number">0</span> | gt    | guard (<span class="hljs-function"><span class="hljs-params">pad</span> =&gt;</span> [str, <span class="hljs-string">' '</span> | repeatChar (pad)] | join (<span class="hljs-string">''</span>)),
  otherwise | guardV (str),
])

<span class="hljs-comment">// --- index.js</span>

<span class="hljs-keyword">import</span> { ArithmeticSequence, GeometricSequence, IrregularSequence, ErrorSequence, } <span class="hljs-keyword">from</span> <span class="hljs-string">'./types'</span>
<span class="hljs-keyword">import</span> { isArithmetic, isGeometric, isError, } <span class="hljs-keyword">from</span> <span class="hljs-string">'./sequence'</span>
<span class="hljs-keyword">import</span> { cata, repeatChar, pad, } <span class="hljs-keyword">from</span> <span class="hljs-string">'./util'</span>

<span class="hljs-keyword">const</span> checkSequence = condS ([
  isArithmetic | guard (<span class="hljs-function">(<span class="hljs-params">_, n</span>) =&gt;</span> n | ArithmeticSequence),
  isGeometric  | guard (<span class="hljs-function">(<span class="hljs-params">_, c</span>) =&gt;</span> c | GeometricSequence),
  containsNull | guard (<span class="hljs-function"><span class="hljs-params">()</span>     =&gt;</span> <span class="hljs-string">'contains null'</span> | ErrorSequence),
  otherwise    | guard (<span class="hljs-function"><span class="hljs-params">()</span>     =&gt;</span> IrregularSequence),
])

<span class="hljs-keyword">const</span> format = cata ({
  <span class="hljs-attr">ArithmeticSequence</span>: <span class="hljs-function"><span class="hljs-params">n</span>      =&gt;</span> [<span class="hljs-string">'arithmetic'</span>, n] | map (yellow) | sprintfN (<span class="hljs-string">'%s: y = %sx'</span>),
  <span class="hljs-attr">GeometricSequence</span>:  <span class="hljs-function"><span class="hljs-params">c</span>      =&gt;</span> [<span class="hljs-string">'geometric'</span>, c]  | map (green) | sprintfN (<span class="hljs-string">'%s: y = %s ** x'</span>),
  <span class="hljs-attr">ErrorSequence</span>:      <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> reason | red | sprintf1 (<span class="hljs-string">'error: %s'</span>),
  <span class="hljs-attr">IrregularSequence</span>:  <span class="hljs-function"><span class="hljs-params">_</span>      =&gt;</span> <span class="hljs-string">'irregular sequence'</span> | brightRed,
})

<span class="hljs-keyword">const</span> repeatChar = <span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> timesV (n) &gt;&gt; join (<span class="hljs-string">''</span>)

<span class="hljs-keyword">const</span> pad = <span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> str =&gt; (n - str.length) | condS ([
  <span class="hljs-number">0</span> | gt    | guard (<span class="hljs-function"><span class="hljs-params">pad</span> =&gt;</span> [str, <span class="hljs-string">' '</span> | repeatChar (pad)] | join (<span class="hljs-string">''</span>)),
  otherwise | guardV (str),
])

<span class="hljs-keyword">const</span> report = <span class="hljs-function"><span class="hljs-params">xs</span> =&gt;</span> resolved =&gt;
  [xs | join (<span class="hljs-string">', '</span>) | pad (<span class="hljs-number">13</span>), resolved]
  | sprintfN (<span class="hljs-string">'%s → %s'</span>)

<span class="hljs-keyword">const</span> doit = <span class="hljs-function"><span class="hljs-params">xs</span> =&gt;</span> xs
  | checkSequence
  | format
  | report (xs)

<span class="hljs-keyword">const</span> go = <span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span>
  [
    [<span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">12</span>],   <span class="hljs-comment">// --- arithmetic</span>
    [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">27</span>],  <span class="hljs-comment">// --- geometric</span>
    [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>],   <span class="hljs-comment">// --- irregular</span>
    [<span class="hljs-literal">null</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>] <span class="hljs-comment">// --- error</span>
  ]
  | map (doit)
  | tap (map (log))

go ()</code></pre><p class="img-container"><img src="readme-assets/seq.jpg" alt="seq.jpg"></p>
<h2 id="point-free-techniques"><a class="header-link" href="#point-free-techniques"></a>Point-free techniques</h2>
<p>We had an <code>isInteger</code> function above as:</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> { floor, } = <span class="hljs-built_in">Math</span>
<span class="hljs-keyword">const</span> isInteger = <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x
  | floor
  | eq (x)</code></pre><p>If a number equals its own floor, it&#39;s an integer.</p>
<p>For a challenge you could try to make this point-free. The difficult part is
wresting the <code>x</code> free out of the 3rd line.</p>
<p>We can use the concept of &#39;arrows&#39;, though in a far less rigorous form than people might be used to.</p>
<p>First spread the first line <code>x</code> into an array <code>[x, x]</code></p>
<pre class="hljs"><code><span class="hljs-keyword">x</span> | timesV (<span class="hljs-number">2</span>) // [<span class="hljs-keyword">x</span>, <span class="hljs-keyword">x</span>]</code></pre><p>Now use the <code>asteriskN</code> function, which works by taking an array of values
and an array of functions, lining them up, and applying the functions to the
corresponding value.</p>
<p>So we can do an asterisk of <code>[x, x]</code> with <code>[id, floor]</code>, where <code>id</code> is the identity function.</p>
<pre class="hljs"><code><span class="hljs-string">[id, floor]</span>
 ↓    ↓
<span class="hljs-string">[x,   x   ]</span></code></pre><p>and get <code>[id (x), floor (x)]</code>, or <code>[x, floor (x)]</code></p>
<p>Now look at the <code>passToN</code> function:</p>
<pre class="hljs"><code><span class="hljs-comment">; [a, b, ...] | passToN (f)</span></code></pre><p>yields <code>f (a, b, ...)</code></p>
<p>If we take our result and pipe it to <code>passToN (eq)</code>, we get:</p>
<pre class="hljs"><code>; [x, <span class="hljs-built-in">floor</span> (x)]
| passToN (<span class="hljs-keyword">eq</span>)</code></pre><p>which is</p>
<pre class="hljs"><code>e<span class="hljs-string">q (x, floor (x)</span>)</code></pre><p>which is true if &amp; only if <code>x === floor (x)</code>, in other words, if &amp;
only if x is an integer.</p>
<p>Putting it together:</p>
<pre class="hljs"><code>const isInteger = x =&gt; x
  | <span class="hljs-type">timesV</span> (<span class="hljs-number">2</span>)
  | <span class="hljs-type">asteriskN</span> ([id, floor])
  | <span class="hljs-type">passToN</span> (eq)</code></pre><p>Applying the reduction <code>a | b | c → a | (b &gt;&gt; c)</code></p>
<pre class="hljs"><code>const isInteger = x =&gt; x
  | <span class="hljs-type">(timesV</span> (<span class="hljs-number">2</span>) &gt;&gt; asteriskN ([id, floor]))
  | <span class="hljs-type">passToN</span> (eq)</code></pre><p>And that long line is useful enough to merit its own function, which takes a
function (in our case <code>floor</code>) to apply to a value in second position. We&#39;ll
call it <code>arrowSnd</code>:</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> arrowSnd = <span class="hljs-function"><span class="hljs-params">f</span> =&gt;</span> timesV (<span class="hljs-number">2</span>) &gt;&gt; asteriskN ([id, f])</code></pre><p>And stick it back in:</p>
<pre class="hljs"><code>const isInteger = x =&gt; x
  | <span class="hljs-type">arrowSnd</span> (floor)
  | <span class="hljs-type">passToN</span> (eq)</code></pre><p>And make it point-free:</p>
<pre class="hljs"><code>const isInteger = arrowSnd (<span class="hljs-name">floor</span>) &gt;&gt; passToN (<span class="hljs-name">eq</span>)</code></pre><p>Your turn :D</p>
<h1 id="extra-performance"><a class="header-link" href="#extra-performance"></a>Extra performance</h1>
<p>The curried functions you import from the main module are written first
using manual currying, and then recurried and exported. This is in order to
allow both calling styles.</p>
<p>If you are squeezing performance out of a loop -- in an animation, a
particle system, WebGL, a server -- you can check the docs to see if your
function is exported by &#39;stick-js/manual&#39;. If so, you can directly import
the manual version, but you must remember to call it using the manual style:</p>
<pre class="hljs"><code>import { merge, } from <span class="hljs-string">'stick-js/manual'</span>
merge <span class="hljs-comment">(obj1, obj2)</span> <span class="hljs-comment">// will not work</span>
obj<span class="hljs-number">2</span> | merge <span class="hljs-comment">(obj1)</span> <span class="hljs-comment">// ok</span>
merge <span class="hljs-comment">(obj1)</span> <span class="hljs-comment">(obj2)</span> <span class="hljs-comment">// also ok</span></code></pre><h1 id="generic-version-of-`lets`"><a class="header-link" href="#generic-version-of-`lets`"></a>Generic version of <code>lets</code></h1>
<p>Here is a generic form of <code>lets</code> which takes any number of non-zero
arguments. We removed it from stick because it depends on <code>mapAccum</code>, for
which we do not currently have an implementation without depending on Ramda.</p>
<pre class="hljs"><code><span class="hljs-comment">// --- generic form, for any non-zero number of arguments.</span>
<span class="hljs-keyword">const</span> lets = <span class="hljs-function">(<span class="hljs-params">(</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> executeStep = <span class="hljs-function"><span class="hljs-params">prevVals</span> =&gt;</span> applyToN (prevVals)
    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">...xs</span>) =&gt;</span> xs
        <span class="hljs-comment">// --- acc contains running output array, up to the previous item.</span>
        | mapAccum (<span class="hljs-function">(<span class="hljs-params">acc, v</span>) =&gt;</span> executeStep (acc) (v)
            | (<span class="hljs-function"><span class="hljs-params">stepVal</span> =&gt;</span> [[...acc, stepVal], stepVal])
        ) ([])
        | prop (<span class="hljs-number">1</span>)
        | last
}) ()</code></pre><p>This is not fast, but it is correct. You can prove it with a contrived
fibonacci example. We&#39;ll model <code>fibonacci (n)</code> as</p>
<pre class="hljs"><code>lets (
  _ =&gt; <span class="hljs-number">1</span>,
  _ =&gt; <span class="hljs-number">1</span>,
  (<span class="hljs-selector-tag">a</span>, b) =&gt; <span class="hljs-selector-tag">a</span> + <span class="hljs-selector-tag">b</span>,
  (_, <span class="hljs-selector-tag">b</span>, c) =&gt; <span class="hljs-selector-tag">b</span> + c,
  ...
  (<span class="hljs-selector-tag">a</span>, <span class="hljs-selector-tag">b</span>, ...) =&gt; [<span class="hljs-selector-tag">a</span>, <span class="hljs-selector-tag">b</span>, ...],
)</code></pre><p>&nbsp;</p>
<pre class="hljs"><code><span class="hljs-keyword">import</span> { list, timesV, applyToN, rangeTo, } <span class="hljs-keyword">from</span> <span class="hljs-string">'stick-js'</span>

<span class="hljs-keyword">const</span> fibonacci = <span class="hljs-function">(<span class="hljs-params">n</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> sumLastTwo = <span class="hljs-function">(<span class="hljs-params">xs</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> l = xs.length
    <span class="hljs-keyword">return</span> xs [l<span class="hljs-number">-1</span>] + xs [l<span class="hljs-number">-2</span>]
  }
  <span class="hljs-keyword">const</span> entry = <span class="hljs-function">(<span class="hljs-params">...prev</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> l = prev.length
    <span class="hljs-keyword">return</span> l === <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> :
           l === <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : sumLastTwo (prev)
  }
  <span class="hljs-keyword">const</span> refs = entry | timesV (n + <span class="hljs-number">1</span>)
  <span class="hljs-keyword">return</span> lets (...refs, list)
}

<span class="hljs-number">1</span> | rangeTo (<span class="hljs-number">20</span>)
  | map (fibonacci)

<span class="hljs-comment">/*
  [ [ 1, 1 ],
    [ 1, 1, 2 ],
    [ 1, 1, 2, 3 ],
    [ 1, 1, 2, 3, 5 ],
    [ 1, 1, 2, 3, 5, 8 ],
    [ 1, 1, 2, 3, 5, 8, 13 ],
    [ 1, 1, 2, 3, 5, 8, 13, 21 ],
    [ 1, 1, 2, 3, 5, 8, 13, 21, 34 ],
    [ 1, 1, 2, 3, 5, 8, 13, 21, 34, 55 ]
    ...
  ]
*/</span></code></pre><h1 id="bitwise-math"><a class="header-link" href="#bitwise-math"></a>Bitwise math</h1>
<p>Of course, we&#39;ve saved your precious bitwise operators. You can either:</p>
<ol class="list">
<li><p>Use the functional form</p>
<pre class="hljs"><code> <span class="hljs-keyword">import</span> { bitwiseOr, bitwiseShiftBy, } <span class="hljs-keyword">from</span> <span class="hljs-string">'stick-js'</span>
 <span class="hljs-number">4</span> | bitwiseOr (<span class="hljs-number">9</span>) <span class="hljs-comment">// 13</span></code></pre></li>
<li><p>Do your bitwise math in a separate scope than that in which the
<code>defineBinaryOperator</code> calls appear. The operators are only overloaded in
the scope in which the calls are made. We recommend doing the bitwise math
in a separate source file and not mixing the two styles in one file.</p>
</li>
</ol>
</body>
</html>
