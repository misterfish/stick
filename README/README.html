<!DOCTYPE html>
<html>
  <head>
    <title>Usage</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link type="text/css" rel="stylesheet" href="assets/style.css" />
    <link type="text/css" rel="stylesheet" href="assets/pilcrow.css" />
    <link type="text/css" rel="stylesheet" href="assets/hljs-github.min.css"/>
  </head>
<body><h2 id="usage"><a class="header-link" href="#usage"></a>Usage</h2>
<h3 id="٭-node"><a class="header-link" href="#٭-node"></a>٭ node</h3>
<pre class="hljs"><code>npm i stick-js <span class="hljs-comment"># or yarn</span>

cat &gt;.babelrc &lt;&lt;EOT
{<span class="hljs-string">"presets"</span>: [<span class="hljs-string">"babel-preset-es2015"</span>, <span class="hljs-string">"stage-0"</span>], <span class="hljs-string">"plugins"</span>: [
    <span class="hljs-string">"babel-plugin-operator-overload"</span>
]}
EOT

node_modules/.bin/babel -d <span class="hljs-class"><span class="hljs-keyword">lib</span> <span class="hljs-title">src</span></span>
node <span class="hljs-class"><span class="hljs-keyword">lib</span>/&lt;<span class="hljs-title">entry</span>-<span class="hljs-title">file</span>&gt;.<span class="hljs-title">js</span></span></code></pre><h3 id="٭-webpack"><a class="header-link" href="#٭-webpack"></a>٭ webpack</h3>
<h4 id="webpack-config:"><a class="header-link" href="#webpack-config:"></a>webpack config:</h4>
<pre class="hljs"><code><span class="hljs-attr">module:</span> {
<span class="hljs-attr">  rules:</span> [
    {
<span class="hljs-attr">      test:</span> /\.js$/,
<span class="hljs-attr">      exclude:</span> /node_modules/,
<span class="hljs-attr">      use:</span> {
<span class="hljs-attr">        loader:</span> <span class="hljs-string">'babel-loader'</span>,
<span class="hljs-attr">        options:</span> {
<span class="hljs-attr">          presets:</span> [[
            <span class="hljs-string">"env"</span>,
            { <span class="hljs-string">"modules"</span>: <span class="hljs-literal">false</span> },
          ]],
<span class="hljs-attr">          plugins:</span> [
            <span class="hljs-string">'operator-overload'</span>,
          ]
        }
      },
    },
    ...
  ]
  ...
  }</code></pre><h2 id="what-we-provide"><a class="header-link" href="#what-we-provide"></a>What we provide</h2>
<ul class="list">
<li><p>A way to start using the pipe (or &#39;stick&#39;) operator today while 
proposal
<a href="https://github.com/tc39/proposal-pipeline-operator">TC39/proposal-pipeline-operator</a>
is still being fleshed out.</p>
<p>Note that we use <code>|</code>, not <code>|&gt;</code>, which is not only easier to overload but
far more pleasant to work with, and which will still work even if/when the
proposal is accepted.</p>
</li>
<li><p>A toolkit of functions centered around this pattern, and a number of
idioms which they facilitate.</p>
<p>You can use our functions, or your own favorite library (Ramda, lodash/fp,
etc.), or mix and match as you like.</p>
</li>
</ul>
<p>The overloading is made possible thanks to the great
<a href="https://github.com/jussi-kalliokoski/babel-plugin-operator-overload">babel-plugin-operator-overload</a>
library by Jussi Kalliokoski (@jussi-kalliokoski).</p>
<h2 id="tl;dr"><a class="header-link" href="#tl;dr"></a>TL;DR</h2>
<ul class="list">
<li><p>-</p>
<pre class="hljs"><code>  ; <span class="hljs-selector-attr">[1, 2, 3]</span>
  | <span class="hljs-selector-tag">map</span> (x =&gt; x + <span class="hljs-number">1</span>)
  | <span class="hljs-selector-tag">join</span> (<span class="hljs-string">'/'</span>)
  | <span class="hljs-selector-tag">green</span>
  | <span class="hljs-selector-tag">sprintf1</span> (<span class="hljs-string">'The answer is %s'</span>)
  | <span class="hljs-selector-tag">log</span> <span class="hljs-comment">// outputs 'The answer is 2/3/4' (colorfully)</span></code></pre></li>
<li><p>-</p>
<pre class="hljs"><code>  <span class="hljs-keyword">const</span> isInteger = <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x === <span class="hljs-built_in">Math</span>.floor (x)
  <span class="hljs-keyword">const</span> ifInteger = isInteger | ifPredicate

  ; [<span class="hljs-number">3.5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4.2</span>]
  | map (ifInteger (<span class="hljs-number">1</span> | add, <span class="hljs-string">'nothing'</span> | always))
  <span class="hljs-comment">// ['nothing', 5, 'nothing']</span></code></pre></li>
<li><p>-</p>
<pre class="hljs"><code>  <span class="hljs-keyword">const</span> convertFahrenheit = fah =&gt; lets (
    _ =&gt; (fah - <span class="hljs-number">32</span>) / <span class="hljs-number">9</span> * <span class="hljs-number">5</span>,    <span class="hljs-comment">// (1) celsius</span>
    (cel) =&gt; cel + <span class="hljs-number">273</span>,         <span class="hljs-comment">// (2) kelvin</span>
    (cel, kel) =&gt; [cel, kel],   <span class="hljs-comment">// (3) result</span>
  )

  convertFahrenheit (<span class="hljs-number">86</span>) <span class="hljs-comment">// [30, 303]</span></code></pre></li>
<li><p>-</p>
<pre class="hljs"><code>  const checkVal = condS ([
    <span class="hljs-number">4</span> | e<span class="hljs-string">q    | guard  (sprintf1 ('%s was 4')),
    4 |</span> <span class="hljs-keyword">lt</span>    | guard  (sprintf1 (<span class="hljs-string">'%s was less than 4'</span>)),
    <span class="hljs-number">4</span> | <span class="hljs-keyword">gt</span>    | guard  (sprintf1 (<span class="hljs-string">'%s was more than 4'</span>)),
    otherwise | guardV (<span class="hljs-string">"error, this shouldn't happen"</span>),
  ])

  ; [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
  | <span class="hljs-keyword">map</span> (checkVal)
  | <span class="hljs-keyword">join</span> (<span class="hljs-string">' | '</span>)
  // <span class="hljs-number">3</span> was less than <span class="hljs-number">4</span> | <span class="hljs-number">4</span> was <span class="hljs-number">4</span> | <span class="hljs-number">5</span> was more than <span class="hljs-number">4</span></code></pre></li>
<li><p>-</p>
<pre class="hljs"><code>  <span class="hljs-comment">// ------ dog.js</span>
  <span class="hljs-keyword">const</span> proto = { speak () { <span class="hljs-string">'Hi from '</span> + <span class="hljs-keyword">this</span>.name }}
  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> proto | <span class="hljs-keyword">factory</span>

  <span class="hljs-comment">// ------ main.js</span>
  <span class="hljs-keyword">import</span> Dog from <span class="hljs-string">'./dog'</span>
  Dog.create ({ name: <span class="hljs-string">'Caesar'</span>, }).speak () <span class="hljs-comment">// 'Hi from Caesar'</span></code></pre></li>
<li><p>and much more.</p>
</li>
</ul>
<h2 id="overview"><a class="header-link" href="#overview"></a>Overview</h2>
<h3 id="٭-basic-example-٭"><a class="header-link" href="#٭-basic-example-٭"></a>٭ basic example ٭</h3>
<pre class="hljs"><code><span class="hljs-regexp">//</span> --- source files must begin with <span class="hljs-keyword">this</span> header.

defineBinaryOperator (<span class="hljs-string">'|'</span>,  <span class="hljs-function"><span class="hljs-params">(...args)</span> =&gt;</span> pipe         (...args))
defineBinaryOperator (<span class="hljs-string">'&lt;&lt;'</span>, <span class="hljs-function"><span class="hljs-params">(...args)</span> =&gt;</span> compose      (...args))
defineBinaryOperator (<span class="hljs-string">'&gt;&gt;'</span>, <span class="hljs-function"><span class="hljs-params">(...args)</span> =&gt;</span> composeRight (...args))

<span class="hljs-keyword">import</span> {
    pipe, compose, composeRight,

<span class="hljs-regexp">//</span> --- /header

    map, join,
} <span class="hljs-keyword">from</span> <span class="hljs-string">'stick-js'</span>

<span class="hljs-keyword">import</span> { green, } <span class="hljs-keyword">from</span> <span class="hljs-string">'chalk'</span>

const { log, } = <span class="hljs-built_in">console</span>

; [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
| map (x =&gt; x + <span class="hljs-number">1</span>)
| join (<span class="hljs-string">'/'</span>)
| green
| sprintf1 (<span class="hljs-string">'The answer is %s'</span>)
| log <span class="hljs-regexp">//</span> outputs <span class="hljs-string">'The answer is 2/3/4'</span> (colorfully)</code></pre><h3 id="٭-the-'stick'-operator-٭"><a class="header-link" href="#٭-the-'stick'-operator-٭"></a>٭ the &#39;stick&#39; operator ٭</h3>
<p><code>a | b</code> is simply an equivalent way of writing <code>b (a)</code></p>
<p>A really simple idea, with some pretty far-reaching consequences.</p>
<p>(What if I really want to do bitwise math, you ask? Don&#39;t worry, you still
can: see below).</p>
<pre class="hljs"><code><span class="hljs-comment">// --- reminder: source files must begin with this.</span>
<span class="hljs-comment">// --- from here on out we'll omit it in the examples.</span>
defineBinaryOperator (<span class="hljs-string">'|'</span>,  (...args) =&gt; pipe         (...args))
defineBinaryOperator (<span class="hljs-string">'&lt;&lt;'</span>, (...args) =&gt; compose      (...args))
defineBinaryOperator (<span class="hljs-string">'&gt;&gt;'</span>, (...args) =&gt; composeRight (...args))

<span class="hljs-keyword">import</span> {
  pipe, compose, composeRight,
  map, join, split,
} from <span class="hljs-string">'stick-js'</span>

<span class="hljs-keyword">const</span> multiply = x =&gt; y =&gt; x * y
<span class="hljs-keyword">const</span> <span class="hljs-built_in">double</span> = multiply (<span class="hljs-number">2</span>)     <span class="hljs-comment">// or 2 | multiply</span>

<span class="hljs-number">3</span> | <span class="hljs-built_in">double</span>                      <span class="hljs-comment">// 6</span>
<span class="hljs-built_in">double</span> (<span class="hljs-number">3</span>)                      <span class="hljs-comment">// 6</span>
<span class="hljs-number">3</span> | multiply (<span class="hljs-number">4</span>)                <span class="hljs-comment">// 12</span>

<span class="hljs-keyword">const</span> capitaliseFirstLetter = x =&gt; x[<span class="hljs-number">0</span>].toUpperCase () + x.slice (<span class="hljs-number">1</span>)

<span class="hljs-string">'just a perfect day'</span>
  | split (<span class="hljs-string">' '</span>)                 <span class="hljs-comment">// split (' ') is a function</span>
  | map (capitaliseFirstLetter) <span class="hljs-comment">// map (capitaliseFirstLetter) is a function</span>
  | join (<span class="hljs-string">' '</span>)                  <span class="hljs-comment">// ... you get the picture.</span>
<span class="hljs-comment">// 'Just A Perfect Day'</span></code></pre><h3 id="٭-currying-styles-٭"><a class="header-link" href="#٭-currying-styles-٭"></a>٭ currying styles ٭</h3>
<p>All curried functions provided by stick-js can be called using either of 2 currying styles.</p>
<p>This would be a good time to read up on curried functions if you&#39;re not familiar with them.</p>
<ol class="list">
<li><p>we will refer to this sort of function and calling style as &#39;manual&#39;:</p>
<pre class="hljs"><code> const f = <span class="hljs-selector-tag">a</span> =&gt; <span class="hljs-selector-tag">b</span> =&gt; c =&gt; <span class="hljs-selector-tag">a</span> + <span class="hljs-selector-tag">b</span> + c          <span class="hljs-comment">// call like f (1) (2) (3)</span></code></pre></li>
<li><p>and this sort as &#39;normal&#39;:</p>
<pre class="hljs"><code> const g = R<span class="hljs-selector-class">.curry</span> ((<span class="hljs-selector-tag">a</span>, <span class="hljs-selector-tag">b</span>, c) =&gt; <span class="hljs-selector-tag">a</span> + <span class="hljs-selector-tag">b</span> + c) <span class="hljs-comment">// call like f (1) (2) (3) or f (1, 2, 3)</span>
                                            <span class="hljs-comment">// or f (1, 2, 3)</span>
                                            <span class="hljs-comment">// or f (1) (2, 3)</span>
                                            <span class="hljs-comment">// etc.</span></code></pre></li>
</ol>
<p>Calling:</p>
<pre class="hljs"><code><span class="hljs-keyword">import</span> { <span class="hljs-built_in">map</span>, } from <span class="hljs-string">'stick-js'</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> = x =&gt; x * <span class="hljs-number">2</span>

<span class="hljs-built_in">map</span> (<span class="hljs-keyword">double</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])    <span class="hljs-comment">// [2, 4, 6] (normal style)</span>
<span class="hljs-built_in">map</span> (<span class="hljs-keyword">double</span>) ([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])   <span class="hljs-comment">// [2, 4, 6] (manual style)</span>
; [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] | <span class="hljs-built_in">map</span> (<span class="hljs-keyword">double</span>) <span class="hljs-comment">// [2, 4, 6] (manual style with stick)</span></code></pre><p>For extra performance you can also limit yourself to the manual style (see
below).</p>
<h3 id="٭-markers-٭"><a class="header-link" href="#٭-markers-٭"></a>٭ markers ٭</h3>
<pre class="hljs"><code><span class="hljs-keyword">import</span> { sprintfN, sprintf1, } <span class="hljs-keyword">from</span> <span class="hljs-string">'stick-js'</span>

<span class="hljs-number">3</span> | sprintf1 (<span class="hljs-string">'4 - 1 is %s'</span>) <span class="hljs-comment">// '4 - 1 is 3'</span></code></pre><p>&#39;N&#39; is a marker meaning an array is expected.</p>
<pre class="hljs"><code>; <span class="hljs-selector-attr">[4, 3]</span>
| <span class="hljs-selector-tag">sprintfN</span> (<span class="hljs-string">'%s - 1 is %s'</span>)  <span class="hljs-comment">// same.</span></code></pre><p>&#39;V&#39; means a value is expected, to disambiguate cases where a function also
fits.</p>
<pre class="hljs"><code>import { timesV, timesF, } from 'stick-js'

const { <span class="hljs-built_in">random</span>, } = Math

<span class="hljs-number">3</span>      | timesV (<span class="hljs-number">4</span>)          // [<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>]
<span class="hljs-built_in">random</span> | timesF (<span class="hljs-number">4</span>)          // [&lt;<span class="hljs-built_in">random</span>-<span class="hljs-built_in">num</span>&gt;, &lt;<span class="hljs-built_in">random</span>-<span class="hljs-built_in">num</span>&gt;, &lt;<span class="hljs-built_in">random</span>-<span class="hljs-built_in">num</span>&gt;, &lt;<span class="hljs-built_in">random</span>-<span class="hljs-built_in">num</span>&gt;]
<span class="hljs-built_in">random</span> | timesV (<span class="hljs-number">4</span>)          // [<span class="hljs-built_in">random</span>, <span class="hljs-built_in">random</span>, <span class="hljs-built_in">random</span>, <span class="hljs-built_in">random</span>]</code></pre><p>Note that the last one stores the function in the array.</p>
<pre class="hljs"><code><span class="hljs-built_in">random</span> | timesV (<span class="hljs-number">4</span>) | <span class="hljs-built_in">map</span> (invoke) // [&lt;<span class="hljs-built_in">random</span>-<span class="hljs-built_in">num</span>&gt;, &lt;<span class="hljs-built_in">random</span>-<span class="hljs-built_in">num</span>&gt;, &lt;<span class="hljs-built_in">random</span>-<span class="hljs-built_in">num</span>&gt;, &lt;<span class="hljs-built_in">random</span>-<span class="hljs-built_in">num</span>&gt;]</code></pre><p>&#39;M&#39; means the data is being mutated. In JS we absolutely can not pretend
everything is immutable.</p>
<pre class="hljs"><code>import { appendTo, appendToM, } from 'stick-js'
<span class="hljs-built_in">
const </span>a = [1, 2, 3]<span class="hljs-built_in">
const </span>b = 4 | appendTo (a) // functional style: the<span class="hljs-built_in"> array </span>is cloned.
b === a // false
<span class="hljs-built_in">
const </span>a = [1, 2, 3]<span class="hljs-built_in">
const </span>b = 4 | appendToM (a) // non-functional style: the<span class="hljs-built_in"> array </span>is mutated.
b === a // true
<span class="hljs-built_in">
const </span>webGLContext = { ... a complicated object ... }
webGLContext | mergeM ({ someProp: false, }) // you probably want mutable here.</code></pre><p>And there are a few more which we&#39;ll see along the way.</p>
<h3 id="٭-ok,-anaphoric-if-٭"><a class="header-link" href="#٭-ok,-anaphoric-if-٭"></a>٭ ok, anaphoric if ٭</h3>
<p><code>ok (x)</code> is false if <code>x</code> is <code>null</code> or <code>undefined</code>. Everything else passes.</p>
<pre class="hljs"><code><span class="hljs-keyword">import</span> { <span class="hljs-built_in">map</span>, ok, notOk, ifOk, } from <span class="hljs-string">'stick-js'</span>

const { <span class="hljs-keyword">log</span>, } = console

; <span class="hljs-meta">[</span><span class="hljs-number">0</span>, <span class="hljs-literal">false</span>, <span class="hljs-string">''</span>, <span class="hljs-built_in">null</span>, <span class="hljs-literal">void</span> <span class="hljs-number">8</span><span class="hljs-meta">]</span>
| map (ok)    // <span class="hljs-meta">[</span><span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span><span class="hljs-meta">]</span>

; <span class="hljs-meta">[</span><span class="hljs-number">0</span>, <span class="hljs-literal">false</span>, <span class="hljs-string">''</span>, <span class="hljs-built_in">null</span>, <span class="hljs-literal">void</span> <span class="hljs-number">8</span><span class="hljs-meta">]</span>
| map (notOk) // <span class="hljs-meta">[</span><span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span><span class="hljs-meta">]</span></code></pre><p>Something we see a lot in JS in the wild is:</p>
<pre class="hljs"><code><span class="hljs-keyword">let</span> answer
<span class="hljs-keyword">if</span> (someVar !== <span class="hljs-literal">undefined</span> &amp;&amp; someVar !== <span class="hljs-literal">null</span>) {
  answer = someVar + <span class="hljs-number">1</span>
} <span class="hljs-keyword">else</span> {
  answer = <span class="hljs-string">'nothing'</span>
}</code></pre><p>This can vastly improved using an &#39;anaphoric if&#39; and a stick idiom.
<code>ifOk</code> takes two functions -- a &#39;then&#39; function and an &#39;else&#39; function.
In the &#39;ok&#39;    case, the value being tested is passed to the function.</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> add1IfYouCan = val =&gt; val | ifOk (
  <span class="hljs-comment">// `that` is here `val`</span>
  that =&gt; that + <span class="hljs-number">1</span>,

  <span class="hljs-comment">// no value is passed.</span>
  _ =&gt; <span class="hljs-string">'nothing'</span>,
)</code></pre><p>A variant, using a point-free add function and the <code>always</code> function:</p>
<pre class="hljs"><code><span class="hljs-keyword">import</span> { add, always, } <span class="hljs-keyword">from</span> <span class="hljs-string">'stick-js'</span>

<span class="hljs-keyword">const</span> add1 = <span class="hljs-number">1</span> | add <span class="hljs-comment">// or add (1)</span>

<span class="hljs-keyword">const</span> add1IfYouCan = <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x | ifOk (
  add1,
  <span class="hljs-string">'nothing'</span> | always,
)</code></pre><p>Usage:</p>
<pre class="hljs"><code>; <span class="hljs-meta">[</span><span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-built_in">null</span>, <span class="hljs-literal">void</span> <span class="hljs-number">8</span><span class="hljs-meta">]</span>
| map (add1IfYouCan) // <span class="hljs-meta">[</span><span class="hljs-number">1</span>, <span class="hljs-number">11</span>, <span class="hljs-string">'nothing'</span>, <span class="hljs-string">'nothing'</span><span class="hljs-meta">]</span></code></pre><h3 id="٭-point-free-٭"><a class="header-link" href="#٭-point-free-٭"></a>٭ point-free ٭</h3>
<p>A common pattern is when the argument to a function is passed immediately into a pipe:</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> add1IfYouCan = <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x | ifOk (add1, <span class="hljs-string">'nothing'</span> | always)</code></pre><p>Since <code>x</code> does not appear anywhere else in the expression, we can simply remove it, along with the function argument:</p>
<pre class="hljs"><code>const add1IfYouCan = ifOk (<span class="hljs-name">add1</span>, 'nothing' | always)</code></pre><p>If the pipe chain consists of more than 1 link …</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> { dot, sprintf1, tap, }
<span class="hljs-keyword">const</span> { log, } = <span class="hljs-built_in">console</span>

<span class="hljs-keyword">const</span> add1IfYouCan = <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x
  | ifOk (add1, <span class="hljs-string">'nothing'</span> | always)
  | <span class="hljs-built_in">String</span>                        <span class="hljs-comment">// conversion using type constructor</span>
  | dot (<span class="hljs-string">'toUpperCase'</span>)
  | sprintf1 (<span class="hljs-string">'The answer is %s'</span>)
  | tap (log)                     <span class="hljs-comment">// outputs 'The answer is 1', 'The answer is NOTHING', ...</span></code></pre><p>… then we remove the <code>x =&gt; x</code> and change all the <code>|</code> to <code>&gt;&gt;</code></p>
<pre class="hljs"><code>const add1IfYouCan =
  ifOk (<span class="hljs-name">add1</span>, 'nothing' | always)  // (<span class="hljs-number">1</span>)
  &gt;&gt; String                        // (<span class="hljs-number">2</span>)
  &gt;&gt; dot ('toUpperCase')           // (<span class="hljs-number">3</span>)
  &gt;&gt; sprintf1 ('The answer is %s') // (<span class="hljs-number">4</span>)
  &gt;&gt; tap (<span class="hljs-name">log</span>)                     // (<span class="hljs-number">5</span>)</code></pre><p>The following pattern holds:</p>
<pre class="hljs"><code>a | <span class="hljs-type">b</span> | <span class="hljs-type">c</span> = a | <span class="hljs-type">(b</span> &gt;&gt; c)</code></pre><p>So when the chains start to get long (as above), you can cut pieces out
using this property. For example, you can refactor lines 2-4 into a new
function:</p>
<pre class="hljs"><code>// --- convert input <span class="hljs-keyword">to</span> <span class="hljs-built_in">String</span>, make uppercase, perform sprintf.
<span class="hljs-keyword">const</span> processString = <span class="hljs-built_in">String</span>
  &gt;&gt; dot (<span class="hljs-string">'toUpperCase'</span>)
  &gt;&gt; sprintf1 (<span class="hljs-string">'The answer is %s'</span>)</code></pre><p>And splice it back in:</p>
<pre class="hljs"><code>const add1IfYouCan = x =&gt; x
  | <span class="hljs-type">ifOk</span> (add1, 'nothing' | <span class="hljs-type">always</span>)
  | <span class="hljs-type">processString</span>
  | <span class="hljs-type">tap</span> (log)</code></pre><p>Or</p>
<pre class="hljs"><code>const add1IfYouCan =
  ifOk (<span class="hljs-name">add1</span>, 'nothing' | always)
  &gt;&gt; processString
  &gt;&gt; tap (<span class="hljs-name">log</span>)</code></pre><h3 id="٭-compositional-predicates-٭"><a class="header-link" href="#٭-compositional-predicates-٭"></a>٭ compositional predicates ٭</h3>
<p><code>ifOk</code> is a convenience for <code>ifPredicate (ok)</code> or <code>ok | ifPredicate</code>.</p>
<p>There is also a &#39;when&#39; form, which has no &#39;else&#39; branch.</p>
<pre class="hljs"><code>import { <span class="hljs-keyword">add</span>, whenOk, } <span class="hljs-keyword">from</span> <span class="hljs-string">'stick-js'</span>

<span class="hljs-keyword">const</span> add1 = <span class="hljs-number">1</span> | <span class="hljs-keyword">add</span> <span class="hljs-comment">// or add (1)</span>

<span class="hljs-number">3</span>    | whenOk (add1) <span class="hljs-comment">// 4</span>
<span class="hljs-literal">null</span> | whenOk (add1) <span class="hljs-comment">// undefined</span></code></pre><p>The selection of <code>if</code> and <code>when</code> functions we provide is intentionally skimpy, to encourage you to compose your own.</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> { <span class="hljs-built_in">floor</span>, } = Math

<span class="hljs-comment">// --- predicate to match integers.</span>
<span class="hljs-keyword">const</span> isInteger = x =&gt; x === <span class="hljs-built_in">floor</span> (x)

<span class="hljs-comment">// --- or how about</span>
<span class="hljs-comment">// import { eq, } from 'stick-js'</span>
<span class="hljs-comment">// const isInteger = x =&gt; x | floor | eq (x)</span>

<span class="hljs-comment">// --- or if you're getting bored:</span>
<span class="hljs-comment">// import { timesV, asterisk, passToN, } from 'stick-js'</span>
<span class="hljs-comment">// const arrowSnd = f =&gt; timesV (2) &gt;&gt; asterisk ([id, f])</span>
<span class="hljs-comment">// const isInteger = arrowSnd (floor) &gt;&gt; passToN (eq)</span>

<span class="hljs-comment">// --- now compose it into an anaphoric if:</span>

<span class="hljs-keyword">const</span> ifInteger = isInteger | ifPredicate

<span class="hljs-keyword">const</span> add1 = <span class="hljs-built_in">add</span> (<span class="hljs-number">1</span>)

; [<span class="hljs-number">3.5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4.2</span>]
| <span class="hljs-built_in">map</span> (ifInteger (add1, <span class="hljs-string">'nothing'</span> | always))
  <span class="hljs-comment">// ['nothing', 5, 'nothing']</span></code></pre><p>More complicated predicates:</p>
<pre class="hljs"><code><span class="hljs-comment">// --- @todo use `allN`</span>
<span class="hljs-keyword">const</span> both = <span class="hljs-function">(<span class="hljs-params">f, g</span>) =&gt;</span> x =&gt; f (x) &amp;&amp; g (x) ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>

<span class="hljs-keyword">const</span> isOdd = <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x % <span class="hljs-number">2</span>

<span class="hljs-keyword">const</span> isOddInteger = both (isInteger, isOdd)
<span class="hljs-keyword">const</span> ifOddInteger = isOddInteger | ifPredicate

; [<span class="hljs-number">3.5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5.5</span>]
| map (ifOddInteger (
  add1,
  <span class="hljs-string">'nothing'</span> | always,
))
| log

; [<span class="hljs-number">3.5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5.5</span>] | map (isOddInteger) | log</code></pre><h3 id="٭-compositional-decoration-٭"><a class="header-link" href="#٭-compositional-decoration-٭"></a>٭ compositional decoration ٭</h3>
<p>Our <code>map</code> function is capped at one argument, meaning the map routine only
gets the value and not the index or the collection.</p>
<pre class="hljs"><code><span class="hljs-keyword">import</span> { map, addIndex, addCollection, } <span class="hljs-keyword">from</span> <span class="hljs-string">'stick-js'</span>

; [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]
| map (<span class="hljs-function"><span class="hljs-params">(x, idx)</span> =&gt;</span> idx) <span class="hljs-regexp">//</span> [<span class="hljs-literal">undefined</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-literal">undefined</span>]</code></pre><p>But:</p>
<pre class="hljs"><code>const mapWithIndex = map | <span class="hljs-type">addIndex</span>
const mapWithCollection = map | <span class="hljs-type">addCollection</span>

; [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]
| <span class="hljs-type">mapWithIndex</span> ((x, idx) =&gt; idx) // [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]

; [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]
| <span class="hljs-type">mapWithCollection</span> ((x, coll) =&gt; coll) // [[<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]]

; [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]
| <span class="hljs-type">(map</span> | <span class="hljs-type">addIndex</span> | <span class="hljs-type">addCollection</span>) ((x, idx, coll) =&gt; ...)

; [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]
| <span class="hljs-type">(map</span> | <span class="hljs-type">addCollection</span> | <span class="hljs-type">addIndex</span>) ((x, coll, idx) =&gt; ...)</code></pre><p>We can also enhance our merge functions, to deal with conflicts:</p>
<pre class="hljs"><code><span class="hljs-keyword">import</span> { mergeWith, mergeToSym, } <span class="hljs-keyword">from</span> <span class="hljs-string">'stick-js'</span>

<span class="hljs-keyword">const</span> chooseTgt = <span class="hljs-function">(<span class="hljs-params">src, tgt</span>) =&gt;</span> tgt
<span class="hljs-keyword">const</span> chooseSrc = <span class="hljs-function">(<span class="hljs-params">src, tgt</span>) =&gt;</span> src

<span class="hljs-comment">// --- choose target value on conflict</span>
<span class="hljs-keyword">const</span> mergeChooseTgt = mergeToSym | mergeWith (chooseTgt)

<span class="hljs-comment">// --- choose source value on conflict</span>
<span class="hljs-keyword">const</span> mergeChooseSrc = mergeToSym | mergeWith (chooseSrc)

<span class="hljs-keyword">const</span> os = { <span class="hljs-attr">name</span>: <span class="hljs-string">'source name'</span>, }
<span class="hljs-keyword">const</span> ot = { <span class="hljs-attr">name</span>: <span class="hljs-string">'target name'</span>, }

os | mergeChooseSrc (ot) <span class="hljs-comment">// 'source name'</span>
os | mergeChooseTgt (ot) <span class="hljs-comment">// 'target name'</span></code></pre><p>Or to only merge if certain conditions hold:</p>
<pre class="hljs"><code>import { mergeWhen, eq, } from <span class="hljs-string">'stick-js'</span>

const { <span class="hljs-built_in">floor</span>, } = Math
const isInteger = <span class="hljs-keyword">x</span> =&gt; <span class="hljs-keyword">x</span> | <span class="hljs-built_in">floor</span> | eq (<span class="hljs-keyword">x</span>)
const srcIsInteger = (src, tgt) =&gt; src | isInteger
const mergeToWhenSrcIsInteger = mergeToSym | mergeWhen (srcIsInteger)

const os = { va<span class="hljs-variable">l:</span> <span class="hljs-number">2.2</span>, <span class="hljs-keyword">vi</span><span class="hljs-variable">l:</span> <span class="hljs-number">3</span>,  vo<span class="hljs-variable">l:</span> <span class="hljs-number">3.5</span>, }
const ot = { va<span class="hljs-variable">l:</span> <span class="hljs-number">25</span>,  <span class="hljs-keyword">vi</span><span class="hljs-variable">l:</span> <span class="hljs-number">25</span>, vo<span class="hljs-variable">l:</span> <span class="hljs-number">25</span>,  <span class="hljs-keyword">ve</span><span class="hljs-variable">l:</span> <span class="hljs-number">42</span>, }

os | mergeTo (ot)                 // { va<span class="hljs-variable">l:</span> <span class="hljs-number">2.2</span>, <span class="hljs-keyword">vi</span><span class="hljs-variable">l:</span> <span class="hljs-number">3</span>, vo<span class="hljs-variable">l:</span> <span class="hljs-number">3.5</span>, <span class="hljs-keyword">ve</span><span class="hljs-variable">l:</span> <span class="hljs-number">42</span>, }
os | mergeToWhenSrcIsInteger (ot) // { va<span class="hljs-variable">l:</span> <span class="hljs-number">25</span>,  <span class="hljs-keyword">vi</span><span class="hljs-variable">l:</span> <span class="hljs-number">3</span>, vo<span class="hljs-variable">l:</span> <span class="hljs-number">25</span>,  <span class="hljs-keyword">ve</span><span class="hljs-variable">l:</span> <span class="hljs-number">42</span>, }</code></pre><h3 id="٭-semantics-and-argument-order-are-often-based-on-english-grammar-٭"><a class="header-link" href="#٭-semantics-and-argument-order-are-often-based-on-english-grammar-٭"></a>٭ semantics and argument order are often based on English grammar ٭</h3>
<p>(We&#39;re dying to see a port to Hungarian, too)</p>
<p>Once you master this, the usage becomes intuitive and greatly reduces the
need to check the docs.</p>
<p>(What&#39;s the argument order of <code>append</code>, <code>times</code>, and <code>subtract</code> in your favorite library?)</p>
<pre class="hljs"><code>import {
  sprintfN, sprintf1, mergeTo, merge, prependTo, prepend,
  appendTo, append, <span class="hljs-built_in">bind</span>PropTo, <span class="hljs-built_in">bind</span>Prop, <span class="hljs-built_in">bind</span>To, <span class="hljs-built_in">bind</span>, invoke,
} from <span class="hljs-string">'stick-js'</span>

const tgt = { thing: <span class="hljs-string">'sandwich'</span>, want: <span class="hljs-string">'no thanks'</span>,  }
const src = {                    want: <span class="hljs-string">'yes please'</span>, }</code></pre><p>When a function ends in a preposition, for example, ‘To’, the identifier to
the right is the object of the preposition.</p>
<p>Read this as ‘merge src <strong>to tgt</strong>’</p>
<pre class="hljs"><code>src | mergeTo (tgt)                  // { thin<span class="hljs-variable">g:</span> <span class="hljs-string">'sandwich'</span>, wan<span class="hljs-variable">t:</span> <span class="hljs-string">'yes please'</span>, }</code></pre><p>The same function without the preposition means that the identifier to the right is the object of the verb ‘merge’.</p>
<p>Read this as: ‘<strong>merge src</strong> to tgt’</p>
<pre class="hljs"><code>tgt | merge (src)                    // { thing: 'sandwich', want: 'yes please', }

4 | appendTo ([1, 2, 3])             // [1, 2, 3, 4]
; ([1, 2, 3]) | append (4)           // [1, 2, 3, 4]

0 | prependTo ([1, 2, 3])            // [0, 1, 2, 3]
; ([1, 2, 3]) | prepend (0)          // [0, 1, 2, 3]
<span class="hljs-built_in">
const </span>dog = {
  name: 'Caesar',
  speak () {<span class="hljs-built_in"> return </span>'My name is ' + this.name },
}
<span class="hljs-built_in">
const </span>cat = {
  name: 'Fritz',
  speak () {<span class="hljs-built_in"> throw </span>new Error },
}
<span class="hljs-built_in">
const </span>f = 'speak' | bindPropTo (dog)
f ()                                  // 'My name is Caesar'

// --- 'bind prop <span class="hljs-string">"speak"</span> to object'
'speak' | bindPropTo (dog)   |<span class="hljs-built_in"> invoke </span>// same

// --- also 'bind prop <span class="hljs-string">"speak"</span> to object'
dog     | bindProp ('speak') |<span class="hljs-built_in"> invoke </span>// same

dog.speak | bindTo (dog) |<span class="hljs-built_in"> invoke </span>    // same

// cat.speak ()                       // Error
dog.speak | bindTo (cat) |<span class="hljs-built_in"> invoke </span>    // 'My name is Fritz'
cat | bind (dog.speak)   |<span class="hljs-built_in"> invoke </span>    // 'My name is Fritz'

// --- 'call this function on this context', i.e., bind<span class="hljs-built_in"> and </span>call.
; ({}.toString) | callOn (3)          // '[object Number]'

// --- 'provide this context to this function'
; 3 | provideTo ({}.toString)         // '[object Number]'</code></pre><p>Note that this fits the <code>a | b | c</code> pattern:</p>
<pre class="hljs"><code>dog.speak | bindTo (cat) |<span class="hljs-built_in"> invoke </span>    // 'My name is Fritz'</code></pre><p>So we can also write it as <code>a | (b &gt;&gt; c)</code>:</p>
<pre class="hljs"><code>dog.speak | (bindTo (cat) &gt;&gt; invoke)  // <span class="hljs-symbol">'My</span> name <span class="hljs-keyword">is</span> Fritz'</code></pre><p>In fact <code>bindTo (x) &gt;&gt; invoke</code> is already provided under the name <code>callOn</code>,
and its inverse <code>provideTo</code>:</p>
<pre class="hljs"><code>dog.speak | callOn (cat)              // <span class="hljs-symbol">'My</span> name <span class="hljs-keyword">is</span> Fritz'
cat       | provideTo (dog.speak)     // <span class="hljs-symbol">'My</span> name <span class="hljs-keyword">is</span> Fritz'</code></pre><p>Some other miscellaneous examples.</p>
<pre class="hljs"><code><span class="hljs-comment">// --- '3 to the 4th'</span>
<span class="hljs-number">3</span> | toThe (<span class="hljs-number">4</span>)                         <span class="hljs-comment">// 81</span>

<span class="hljs-comment">// --- '3 divided by 6'</span>
<span class="hljs-number">3</span> | divideBy (<span class="hljs-number">6</span>)                      <span class="hljs-comment">// 0.5</span>

<span class="hljs-comment">// --- 'divide 3 into 6'</span>
<span class="hljs-number">3</span> | divideInto (<span class="hljs-number">6</span>)                    <span class="hljs-comment">// 2</span>

<span class="hljs-comment">// --- 'subtract 3 from 4'</span>
<span class="hljs-number">3</span> | subtractFrom (<span class="hljs-number">4</span>)                  <span class="hljs-comment">// 1</span>

<span class="hljs-comment">// --- 'subtract 4 from 3'</span>
<span class="hljs-number">3</span> | subtract (<span class="hljs-number">4</span>)                      <span class="hljs-comment">// -1</span>

<span class="hljs-comment">// --- '3 minus 4'</span>
<span class="hljs-number">3</span> | minus (<span class="hljs-number">4</span>)                         <span class="hljs-comment">// -1</span></code></pre><h3 id="٭-side-effects-&-chaining-٭-mutable-vs-immutable-٭"><a class="header-link" href="#٭-side-effects-&-chaining-٭-mutable-vs-immutable-٭"></a>٭ side effects &amp; chaining ٭ mutable vs immutable ٭</h3>
<pre class="hljs"><code><span class="hljs-keyword">import</span> {
  <span class="hljs-keyword">map</span>, side1, appendM, <span class="hljs-built_in">append</span>, prependM, prepend,
} from <span class="hljs-string">'stick-js'</span></code></pre><p>Chaining with the <code>.</code> will often not do what you want.</p>
<pre class="hljs"><code>; [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]
  .push (<span class="hljs-number">5</span>)
  .unshift (<span class="hljs-number">1</span>) <span class="hljs-comment">// error, return value of previous line was 5</span></code></pre><p>But this will:</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> push    = <span class="hljs-string">'push'</span>    | side1
<span class="hljs-keyword">const</span> unshift = <span class="hljs-string">'unshift'</span> | side1</code></pre><p>The 1 in side1 refers to the arity of the function, i.e., the exact number
of arguments it expects. When working with functions in this way it&#39;s
important to specify this.</p>
<p><code>.push</code> and <code>.unshift</code>, both methods of <code>Array.prototype</code>, expect exactly
one argument, hence <code>side1</code> in both caes.</p>
<pre class="hljs"><code>; [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]
| push (<span class="hljs-number">5</span>)
| unshift (<span class="hljs-number">1</span>) <span class="hljs-comment">// [1, 2, 3, 4, 5]</span>

<span class="hljs-comment">// --- using stick functions for mutable data:</span>

; [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]
| appendM (<span class="hljs-number">5</span>)
| prependM (<span class="hljs-number">1</span>)

<span class="hljs-comment">// --- using stick functions for immutable data:</span>

; [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]
| append (<span class="hljs-number">5</span>)  <span class="hljs-comment">// new array [2, 3, 4, 5]</span>
| prepend (<span class="hljs-number">1</span>) <span class="hljs-comment">// new array [1, 2, 3, 4, 5]</span></code></pre><h3 id="٭-factory-٭-synopsis-٭"><a class="header-link" href="#٭-factory-٭-synopsis-٭"></a>٭ factory ٭ synopsis ٭</h3>
<pre class="hljs"><code><span class="hljs-keyword">import</span> {
  <span class="hljs-keyword">factory</span>, factoryProps,
  factoryStatics,
} from <span class="hljs-string">'stick-js'</span>

<span class="hljs-comment">// --- dog.js:</span>
<span class="hljs-keyword">const</span> proto = {
  init () {
    ...
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>
  },
  breathe () { <span class="hljs-keyword">return</span> <span class="hljs-string">'huff'</span> },
  whoami ()  { <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name },
  getType () { <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.type },
}

<span class="hljs-keyword">const</span> props = {
  type: <span class="hljs-string">'dog'</span>,
  name: undefined,
}

<span class="hljs-comment">// --- basic:</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> proto | <span class="hljs-keyword">factory</span>

<span class="hljs-comment">// --- variants:</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> proto | <span class="hljs-keyword">factory</span> | factoryProps (props)
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> proto | <span class="hljs-keyword">factory</span> | factoryStatics ({ ... }) | factoryProps (props)

<span class="hljs-comment">// ------ main.js</span>

<span class="hljs-keyword">import</span> Dog from <span class="hljs-string">'./dog'</span>

<span class="hljs-keyword">const</span> dog = Dog.create ()
<span class="hljs-comment">// const dog = Dog.create ().init () // useful in practice</span>
dog.breathe ()                       <span class="hljs-comment">// 'huff'</span>
dog.type                             <span class="hljs-comment">// 'dog', if `factoryProps` used</span>
dog.getType ()                       <span class="hljs-comment">// 'dog', same</span>
dog.whoami ()                        <span class="hljs-comment">// undefined, because no default.</span>

<span class="hljs-keyword">const</span> dog2 = Dog.create ({ name: <span class="hljs-string">'garfunkel'</span>, })
dog2.whoami ()                       <span class="hljs-comment">// 'garfunkel', thanks to args to create</span></code></pre><h3 id="٭-factory-٭-with-mixins-٭-synopsis-٭"><a class="header-link" href="#٭-factory-٭-with-mixins-٭-synopsis-٭"></a>٭ factory ٭ with mixins ٭ synopsis ٭</h3>
<pre class="hljs"><code><span class="hljs-comment">// ------ animal.js:</span>

<span class="hljs-keyword">import</span> {
  factory, factoryStatics, mixinM, mixinPreM,
  factoryProps,
  ifPredicate,
} <span class="hljs-keyword">from</span> <span class="hljs-string">'stick-js'</span>

<span class="hljs-keyword">const</span> isOdd = <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x % <span class="hljs-number">2</span> !== <span class="hljs-number">0</span>
<span class="hljs-keyword">const</span> ifOdd = isOdd | ifPredicate

<span class="hljs-comment">// --- a 'base' object (animal)</span>

<span class="hljs-keyword">const</span> proto = {
  init () {
    ...
    return <span class="hljs-keyword">this</span>
  },
  move () {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.numLegs | ifOdd (
      <span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> <span class="hljs-string">'hobble'</span>,
      _ =&gt; <span class="hljs-string">'gait'</span>,
    )
  },
  breathe () { <span class="hljs-keyword">return</span> <span class="hljs-string">'huff'</span> },
  speak ()   { <span class="hljs-string">'not implemented'</span> | die },
  getType () { <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.type },
}

<span class="hljs-keyword">const</span> props = {
  <span class="hljs-attr">type</span>: <span class="hljs-string">'animal'</span>,
  <span class="hljs-attr">numLegs</span>: <span class="hljs-literal">undefined</span>,
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> proto | factory | factoryProps (props)

<span class="hljs-comment">// ------ cheater.js:</span>

<span class="hljs-comment">// --- some orthogonal functionality</span>

<span class="hljs-keyword">const</span> proto = {
  <span class="hljs-attr">cheat</span>: <span class="hljs-function"><span class="hljs-params">howMuch</span> =&gt;</span> <span class="hljs-string">'I cheat '</span> + howMuch,
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> proto | factory

<span class="hljs-comment">// ------ dog.js:</span>

<span class="hljs-keyword">import</span> {
  sprintf1,
  factory,
} <span class="hljs-keyword">from</span> <span class="hljs-string">'stick-js'</span>

<span class="hljs-keyword">import</span> Animal <span class="hljs-keyword">from</span> <span class="hljs-string">'./animal'</span>
<span class="hljs-keyword">import</span> Cheater <span class="hljs-keyword">from</span> <span class="hljs-string">'./cheater'</span>

<span class="hljs-keyword">const</span> { <span class="hljs-attr">proto</span>: animalProto, } = Animal
<span class="hljs-keyword">const</span> { <span class="hljs-attr">proto</span>: cheaterProto, } = Cheater

<span class="hljs-comment">// --- a composite object (dog), extended from animal, with extra functions mixed in.</span>

<span class="hljs-keyword">const</span> proto = {
  init () {
    ...
    return <span class="hljs-keyword">this</span>
  },
  speak () { <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name | sprintf1 (<span class="hljs-string">'Dog %s says woof'</span>) }
}

<span class="hljs-keyword">const</span> props = {
  <span class="hljs-attr">type</span>: <span class="hljs-string">'dog'</span>,
  <span class="hljs-attr">numLegs</span>: <span class="hljs-number">4</span>,
  <span class="hljs-attr">name</span>: <span class="hljs-literal">undefined</span>,
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> proto
  | mixinPreM (animalProto)
  | mixinM (cheaterProto)
  | factory
  | factoryProps (props)

<span class="hljs-comment">// ------ main.js</span>

<span class="hljs-keyword">import</span> Dog <span class="hljs-keyword">from</span> <span class="hljs-string">'./dog'</span>

<span class="hljs-keyword">const</span> dog = Dog.create ({ <span class="hljs-attr">name</span>: <span class="hljs-string">'garfunkel'</span>, })
<span class="hljs-comment">// const dog = Dog.create ({ name: 'garfunkel', }).init () // with init</span>
dog.breathe ()                                  <span class="hljs-comment">// 'huff' (from animal)</span>
dog.getType ()                                  <span class="hljs-comment">// 'dog' (function from animal, property from dog)</span>
dog.speak ()                                    <span class="hljs-comment">// 'Dog garfunkel says woof' (function from dog, property from instance initialisation)</span>
dog.cheat (<span class="hljs-string">'a bit'</span>)                             <span class="hljs-comment">// 'I cheat a bit' (from cheater)</span></code></pre><p>Stick idioms:</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> breathe = dot (<span class="hljs-string">'breathe'</span>)
<span class="hljs-keyword">const</span> getType = dot (<span class="hljs-string">'getType'</span>)
<span class="hljs-keyword">const</span> speak = dot (<span class="hljs-string">'speak'</span>)
<span class="hljs-keyword">const</span> cheat = dot1 (<span class="hljs-string">'cheat'</span>)
<span class="hljs-keyword">const</span> init = side (<span class="hljs-string">'init'</span>)
<span class="hljs-keyword">const</span> <span class="hljs-keyword">create</span> = dot1 (<span class="hljs-string">'create'</span>)

<span class="hljs-keyword">const</span> dog = Dog
  | <span class="hljs-keyword">create</span> (<span class="hljs-comment">{ name: 'garfunkel', }</span>)
  | init

dog | breathe
dog | getType
dog | speak

Dog | <span class="hljs-keyword">create</span> (<span class="hljs-comment">{ name: 'garfunkel', }</span>)
    | init
    | cheat</code></pre><h3 id="٭-factory-٭-explained"><a class="header-link" href="#٭-factory-٭-explained"></a>٭ factory ٭ explained</h3>
<p>We provide a functional style for working with objects the way JS was
designed to: using prototypical inheritance and Object.create. We hope to
show you that the <code>new</code> keyword and &#39;classes&#39; and all the baggage they bring
are unnecessary, and that they obfuscate the way that it actually works.</p>
<p>We provide a simple abstraction for factories, with as little sugar
and magic as possible, and encourage you to mix and match the components to
do exactly what you need.</p>
<p>To recap: you create an object in JS by first building a prototype object,
consisting of only functions.</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> animalProto = {
  breathe () { <span class="hljs-keyword">return</span> <span class="hljs-string">'huff'</span> },
  speak () { <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span> },
  ...
}</code></pre><p>To make an <code>animal</code> instance, you pass this prototype object to Object.create,
then assign properties. If you wish you can treat one of these instances as
a prototype for a new kind of object, a <code>dog</code> for example, copy in some
more functions, use Object.create again, and so on.</p>
<p>We encapsulate this process with the notion of a factory, which is an object
which knows how to spawn objects of a certain type.</p>
<pre class="hljs"><code><span class="hljs-keyword">import</span> { <span class="hljs-keyword">factory</span>, } from <span class="hljs-string">'stick-js'</span>

<span class="hljs-keyword">const</span> animalProto = {
  breathe () { <span class="hljs-keyword">return</span> <span class="hljs-string">'huff'</span> },
  speak () { <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error },
  ...
}

<span class="hljs-keyword">const</span> Animal = animalProto | <span class="hljs-keyword">factory</span> <span class="hljs-comment">// other idioms might call it `animal` or `animalFactory`</span>
<span class="hljs-keyword">const</span> animal1 = Animal.create ()
<span class="hljs-keyword">const</span> animal2 = Animal.create ()
animal1.breathe () <span class="hljs-comment">// 'huff'</span>
animal2.breathe () <span class="hljs-comment">// 'huff'</span>
animal2.speak () <span class="hljs-comment">// Error</span></code></pre><p>To add properties:</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> animalProps = {
  <span class="hljs-keyword">type</span>: <span class="hljs-string">'animal'</span>,
  size: <span class="hljs-literal">undefined</span>,
  numLegs: <span class="hljs-literal">undefined</span>,
}</code></pre><p>And we recommend always having an <code>init</code> method, which you will almost certainly
need. <code>myFactory.create ().init ()</code> becomes a well-worn pattern.</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> isOdd = x =&gt; x % <span class="hljs-number">2</span> !== <span class="hljs-number">0</span>
<span class="hljs-keyword">const</span> ifOdd = isOdd | ifPredicate

<span class="hljs-keyword">const</span> animalProto = {
  init () {
    ...
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>
  },
  breathe () { <span class="hljs-keyword">return</span> <span class="hljs-string">'huff'</span> },
  speak () { <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error },
  move () {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.numLegs | ifOdd (
      _ =&gt; <span class="hljs-string">'hobble'</span>,
      _ =&gt; <span class="hljs-string">'gait'</span>,
    )
  },
}

<span class="hljs-keyword">const</span> Animal = animalProto | <span class="hljs-keyword">factory</span> | factoryProps (animalProps)</code></pre><p>On <code>create</code>, the properties which are &#39;ok&#39; will get copied in to the new
object.</p>
<p>The others are there for documentation: put them here, not peppered
throughout the methods. Do use <code>undefined</code> for props that are waiting to be
defined, which is arguably better than <code>null</code> and definitely better than
<code>false</code>. Use <code>void 8</code> or your very own favorite number to impress … no one.</p>
<pre class="hljs"><code>const animal = Animal<span class="hljs-selector-class">.create</span> ()<span class="hljs-selector-class">.init</span> ()
animal<span class="hljs-selector-class">.type</span> <span class="hljs-comment">// 'animal'</span>
animal<span class="hljs-selector-class">.size</span> <span class="hljs-comment">// undefined</span></code></pre><p>You can pass an object to <code>create</code> to initialise properties. These will be
copied in <em>after</em> the props that were passed to <code>factoryProps</code> are.</p>
<pre class="hljs"><code>const bigBiped = Animal<span class="hljs-selector-class">.create</span> ({ size: <span class="hljs-string">'big'</span>, numLegs: <span class="hljs-number">2</span>, })<span class="hljs-selector-class">.init</span> ()</code></pre><p>You can also eliminate the dots entirely:</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> create = dot1 (<span class="hljs-string">'create'</span>)
<span class="hljs-keyword">const</span> init   = side (<span class="hljs-string">'init'</span>)
<span class="hljs-keyword">const</span> <span class="hljs-built_in">move</span>   = dot  (<span class="hljs-string">'move'</span>)
<span class="hljs-keyword">const</span> speak  = dot  (<span class="hljs-string">'speak'</span>)

Animal | create ({ <span class="hljs-built_in">size</span>: <span class="hljs-string">'small'</span>, numLegs: <span class="hljs-number">2</span>, })
       | init
       | <span class="hljs-built_in">move</span> <span class="hljs-comment">// 'gait'</span></code></pre><p>Note that by using <code>side</code> for <code>init</code> we are assured that the instance is
passed down through the pipe and not the return value of <code>init</code> (although in
this case, <code>init</code> returns <code>this</code>, so <code>dot</code> would have worked too.) <code>create</code>
and <code>move</code> definitely need <code>dot</code> and not <code>side</code>.</p>
<p>To extend <code>Animal</code> to the obligatory <code>Dog</code> find the <code>Animal</code> prototype
(if <code>animalProto</code> is not in scope).</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> animalProto = Animal.proto</code></pre><p>Or</p>
<pre class="hljs"><code>const animalProto = Animal.create ().__proto__ // might <span class="hljs-keyword">not</span> be available <span class="hljs-keyword">in</span> <span class="hljs-keyword">all</span> runtimes</code></pre><p>Create it, add dog methods, and make a new factory:</p>
<pre class="hljs"><code>const dogProto = animalProto
  | Object.create
  | mergeM ({
    speak () { <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.loud ? <span class="hljs-string">'WOOF'</span> : <span class="hljs-string">'woof'</span> },
  })

const dogProps = {
  numLegs: <span class="hljs-number">4</span>,
  loud: <span class="hljs-literal">undefined</span>,
}

const Dog = dogProto | factory | factoryProps (dogProps)

; [<span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>]
| map (<span class="hljs-function"><span class="hljs-params">(loudness)</span> =&gt;</span> Dog
  | create ({ loud: loudness, })
  | (dog =&gt; [dog.speak (), dog.breathe (), dog.move ()])
)
<span class="hljs-regexp">//</span> [[<span class="hljs-string">'WOOF'</span>, <span class="hljs-string">'huff'</span>, <span class="hljs-string">'gait'</span>], [<span class="hljs-string">'woof'</span>, <span class="hljs-string">'huff'</span>, <span class="hljs-string">'gait'</span>]]</code></pre><p>Note that we can call methods of both <code>Animal</code> and <code>Dog</code> now.</p>
<h3 id="٭-factory-٭-with-mixins-٭-explained-٭"><a class="header-link" href="#٭-factory-٭-with-mixins-٭-explained-٭"></a>٭ factory ٭ with mixins ٭ explained ٭</h3>
<pre class="hljs"><code>const Dog = dogProto | <span class="hljs-type">mixinM</span> (animalProto) | <span class="hljs-type">factory</span> | <span class="hljs-type">factoryProps</span> (dogProps)</code></pre><p>Working with mixins is tricky. At some point, there will be namespace
conflicts and it&#39;s not always obvious which version should win out -- and
you have to decide how you want to deal with that.</p>
<p>But you have all the tools now to specify exactly how you want it to work.
Now you have what JS is known for giving you a lot of: freedom.</p>
<pre class="hljs"><code>const Dog = dogProto | <span class="hljs-type">mixinPreM</span> (animalProto) | <span class="hljs-type">factory</span> | <span class="hljs-type">factoryProps</span> (dogProps)
const dog1 = Dog | <span class="hljs-type">create</span> ({})
dog1 | <span class="hljs-type">breathe</span> // 'huff'
const Dog = dogProto | <span class="hljs-type">mixinPreM</span> (animalProto) | <span class="hljs-type">factory</span> | <span class="hljs-type">factoryProps</span> (dogProps)
Dog.create ({}) | <span class="hljs-type">speak</span> // 'woof'</code></pre><p>We mixed the animal into the dog as a &#39;pre&#39; mixin, meaning that on name
conflicts, Dog&#39;s version will win. If we had used <code>mixinM</code> instead of
<code>mixinPreM</code>:</p>
<pre class="hljs"><code>const Dog = dogProto | <span class="hljs-type">mixinM</span> (animalProto) | <span class="hljs-type">factory</span> | <span class="hljs-type">factoryProps</span> (dogProps)
Dog | <span class="hljs-type">create</span> ({})
    | <span class="hljs-type">speak</span> // Error, this is Animal's version.</code></pre><p>Non-pre mixins are useful for orthogonal functionality -- something like
logging, for example.</p>
<p>You can add as many pre and post mixins as you like.</p>
<pre class="hljs"><code>dogProto |<span class="hljs-string"> mixinPreM (...) </span>|<span class="hljs-string"> ... </span>|<span class="hljs-string"> mixinM (...) </span>|<span class="hljs-string"> ... </span>|<span class="hljs-string"> factory</span></code></pre><p>Or use the &#39;N&#39; versions to provide an array:</p>
<pre class="hljs"><code>dogProto | <span class="hljs-type">mixinPreNM</span> ([a, b, c]) | <span class="hljs-type">mixinNM</span> ([d, e, f]) | <span class="hljs-type">factory</span></code></pre><p>Note the &#39;M&#39; marker on the mixin functions. This is to make clear that these
functions mutate the prototype object, which might be a bit surprising when
using this style. We do not provide non-M versions of the mixin functions,
because it&#39;s not obvious exactly what the semantics should be, as several
alternatives could be equally intuitive.</p>
<p>Should the prototype chain be flattened? Should it be discarded, leaving
only the own keys? Should it create a new object using and mutate it?</p>
<p>You can specify these behaviors explicitly:</p>
<pre class="hljs"><code>dogProto |<span class="hljs-string"> flattenPrototype </span>|<span class="hljs-string"> &lt;mixin functions ...&gt; </span>|
dogProto |<span class="hljs-string"> discardPrototype </span>|<span class="hljs-string"> &lt;mixin functions ...&gt; </span>|
dogProto |<span class="hljs-string"> Object.create    </span>|<span class="hljs-string"> &lt;mixin functions ...&gt; </span>|</code></pre><h3 id="٭-let-expressions-٭"><a class="header-link" href="#٭-let-expressions-٭"></a>٭ let expressions ٭</h3>
<p>You can consolidate a number of assignment statements into a single let
expression, and also limit the scope of the assignments in a way which is
easy to read. Code which is more expression-heavy can often be much easier
to follow at a glance &amp; refactor, especially considering that each statement
is a possible side-effect inducing timebomb.</p>
<pre class="hljs"><code><span class="hljs-comment">// --- convert a celsius value to both fahrenheit &amp; kelvin.</span>

const convertCelsius = (c) =&gt; letV (
  c / <span class="hljs-number">5</span> * <span class="hljs-number">9</span> + <span class="hljs-number">32</span>, <span class="hljs-comment">// fahrenheit</span>
  c - <span class="hljs-number">273</span>,   <span class="hljs-comment">// kelvin</span>
  (fah, kel) =&gt; [fah, kel],
)</code></pre><p><code>letV</code> takes an arbitrary number of values, and expects the last one to be a
function. It simply passes the values in order to the function.</p>
<p>There is an &#39;N&#39; form (<code>letVN</code>, which takes an array of values and one
function).</p>
<p>Far more useful is <code>lets</code> and <code>letS</code>. (Think &#39;let*&#39; in racket).</p>
<p>If we went the other way:</p>
<pre class="hljs"><code><span class="hljs-comment">// --- convert fahrenheit to celsius &amp; kelvin</span>

const convertFahrenheit = (f) =&gt; letV (
  (f - <span class="hljs-number">32</span>) / <span class="hljs-number">9</span> * <span class="hljs-number">5</span>,      <span class="hljs-comment">// celsius</span>
  (f - <span class="hljs-number">32</span>) / <span class="hljs-number">9</span> * <span class="hljs-number">5</span> + <span class="hljs-number">273</span> <span class="hljs-comment">// kelvin</span>
  (cel, kel) =&gt; [cel, kel],
)</code></pre><p>We see that we are wasting work. With <code>lets</code>, it would be:</p>
<pre class="hljs"><code><span class="hljs-comment">// --- convert fahrenheit to celsius &amp; kelvin</span>

<span class="hljs-keyword">const</span> convertFahrenheit = fah =&gt; lets (
  _ =&gt; (fah - <span class="hljs-number">32</span>) / <span class="hljs-number">9</span> * <span class="hljs-number">5</span>,    <span class="hljs-comment">// (1) celsius</span>
  (cel) =&gt; cel + <span class="hljs-number">273</span>,         <span class="hljs-comment">// (2) kelvin</span>
  (cel, kel) =&gt; [cel, kel],   <span class="hljs-comment">// (3) result</span>
)</code></pre><p><code>lets</code> expects each line to be a function. The first line is called with no
argument. The result (1) is passed as the argument to (2). (1) and the
result of (2) are passed as the arguments to (3), and so on. The result of
the last function is the result of the expression.</p>
<p>(For now, there can be up to 6 lines. See below for a generic version).</p>
<p>And of course there is a stick version of <code>lets</code> called <code>letS</code>. Think of the
&#39;S&#39; marker as &#39;stick enabled&#39; and the &#39;s&#39; as &#39;stick disabled&#39;. <code>letS</code>
expects a value to be piped in. <em>Note</em>: the &#39;S&#39; marker implies the &#39;N&#39;
marker: the arguments must be an array, or else it would be impossible to
curry.</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> convertFahrenheit = fah =&gt; fah | letS ([
  (fah) =&gt; (fah - <span class="hljs-number">32</span>) / <span class="hljs-number">9</span> * <span class="hljs-number">5</span>,     <span class="hljs-comment">// (1) celsius</span>
  (fah, cel) =&gt; cel + <span class="hljs-number">273</span>,         <span class="hljs-comment">// (2) kelvin</span>
  (fah, cel, kel) =&gt; [cel, kel]    <span class="hljs-comment">// (3) result</span>
])</code></pre><p>This wouldn&#39;t be the most natural use of <code>letS</code>, but it shows how it works:
Function (1) receives as a single argument the piped in value (<code>fah</code> in this case).
Function (2) receives <code>fah</code>, and the result of (1). (3) receives <code>fah</code>, the
results of (1) and (2), and so on. </p>
<p>By now we know that we can remove <code>fah =&gt; fah |</code> from the first line to
make it point-free, and we can use underscores to indicate ignored values:</p>
<pre class="hljs"><code>const convertFahrenheit = letS ([
  (fah) =&gt; (fah - <span class="hljs-number">32</span>) / <span class="hljs-number">9</span> * <span class="hljs-number">5</span>,
  <span class="hljs-function"><span class="hljs-params">(_, cel)</span> =&gt;</span> cel + <span class="hljs-number">273</span>,
  <span class="hljs-function"><span class="hljs-params">(_, cel, kel)</span> =&gt;</span> [cel, kel],
])</code></pre><p>As an exercise you could try to make the entire expression as point-free as
possible, at the expense of everyone&#39;s sanity:</p>
<pre class="hljs"><code><span class="hljs-keyword">import</span> { letS, <span class="hljs-keyword">minus</span>, divideBy, <span class="hljs-keyword">multiply</span>, add, arg1, list, tail, } <span class="hljs-keyword">from</span> <span class="hljs-string">'stick-js'</span>

const convertFahrenheit = letS ([
  <span class="hljs-keyword">minus</span> (<span class="hljs-number">32</span>) &gt;&gt; divideBy (<span class="hljs-number">9</span>) &gt;&gt; <span class="hljs-keyword">multiply</span> (<span class="hljs-number">5</span>),
  arg1 &gt;&gt; add (<span class="hljs-number">273</span>),
  list &gt;&gt; tail,
])

convertFahrenheit (<span class="hljs-number">86</span>) <span class="hljs-comment">// [30, 303]</span></code></pre><h3 id="٭-exceptions-٭-try/catch-٭"><a class="header-link" href="#٭-exceptions-٭-try/catch-٭"></a>٭ exceptions ٭ try/catch ٭</h3>
<pre class="hljs"><code><span class="hljs-keyword">import</span> { tryCatch, } <span class="hljs-keyword">from</span> <span class="hljs-string">'stick-js'</span>

const dubiousFunction = ...

dubiousFunction | tryCatch (
  <span class="hljs-regexp">//</span> --- <span class="hljs-literal">no</span> exception: `<span class="javascript">v</span>` <span class="hljs-keyword">is</span> the <span class="hljs-keyword">return</span> value <span class="hljs-keyword">of</span> `<span class="javascript">dubiousFunction</span>`
  (v) =&gt; ...,

  <span class="hljs-regexp">//</span> --- exception thrown: `<span class="javascript">e</span>` <span class="hljs-keyword">is</span> the exception
  (e) =&gt; e | decorateException (<span class="hljs-string">'Dubious function said:'</span>)
)</code></pre><p>Sometimes it&#39;s nice to rethrow an exception, with a string prefixed to it so
you can tell what went wrong:</p>
<pre class="hljs"><code>  (e) =&gt; e | decorateException (<span class="hljs-string">'Dubious function said:'</span>) | <span class="hljs-keyword">die</span>

<span class="hljs-keyword">const</span> throwError = reason =&gt; reason
  | <span class="hljs-keyword">exception</span> <span class="hljs-comment">// new Error (reason)</span>
  | raise     <span class="hljs-comment">// throw it</span>

<span class="hljs-keyword">const</span> throwError = reason =&gt; reason | (<span class="hljs-keyword">exception</span> &gt;&gt; raise)

<span class="hljs-comment">// `exception &gt;&gt; raise` is also known as `die`</span></code></pre><p>Note that this is illegal in JS, because <code>throw</code> is not an expression:</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> throwError = <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span> (reason)</code></pre><p>But we can trick it like this:</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> throwError = <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> reason | die

<span class="hljs-comment">// or just</span>
<span class="hljs-comment">// const error = die</span></code></pre><p>Now we can improve this common code:</p>
<pre class="hljs"><code><span class="hljs-keyword">let</span> answer
<span class="hljs-keyword">try</span> {
    answer = dubiousFunction ()
} <span class="hljs-keyword">catch</span> (e) {
    console.warn (e)
    answer = <span class="hljs-string">'bad news'</span>
}</code></pre><p>Like this:</p>
<pre class="hljs"><code>const answer = dubiousFunction | tryCatch (
  plus (<span class="hljs-number">10</span>),
  <span class="hljs-function"><span class="hljs-params">(e)</span> =&gt;</span> {
      e | decorateException (<span class="hljs-string">"That didn't go well"</span>)
        | <span class="hljs-built_in">console</span>.warn
      <span class="hljs-keyword">return</span> <span class="hljs-string">'bad news'</span>
  },
}</code></pre><p>Or perhaps:</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> answer = dubiousFunction | tryCatch (
  plus (<span class="hljs-number">10</span>),
  decorateException (<span class="hljs-string">"That didn't go well"</span>)
    &gt;&gt; tap (<span class="hljs-built_in">console</span>.warn)
    &gt;&gt; (<span class="hljs-string">'bad news'</span> | always)
)</code></pre><h3 id="٭-cond-٭"><a class="header-link" href="#٭-cond-٭"></a>٭ cond ٭</h3>
<pre class="hljs"><code><span class="hljs-keyword">import</span> {
  cond, condN, condS, guard, guardV, sprintf1, <span class="hljs-keyword">otherwise</span>,
} <span class="hljs-keyword">from</span> <span class="hljs-string">'stick-js'</span></code></pre><p>Naive form:</p>
<pre class="hljs"><code>cond (
  [<span class="hljs-number">3</span> === <span class="hljs-number">4</span>, _ =&gt; <span class="hljs-string">'strange'</span>],
  [<span class="hljs-number">3</span> === <span class="hljs-number">5</span>, _ =&gt; <span class="hljs-string">'even stranger'</span>],
  [<span class="hljs-keyword">null</span>, _ =&gt; <span class="hljs-string">'ok'</span>],
)</code></pre><p>An arbitrary number of lines can be provided.</p>
<p>With a stick idiom:</p>
<pre class="hljs"><code>cond (
  (<span class="hljs-keyword">_</span> =&gt; <span class="hljs-number">3</span> === <span class="hljs-number">4</span>) | <span class="hljs-type">guard</span> (<span class="hljs-keyword">_</span> =&gt; 'strange'),
  (<span class="hljs-keyword">_</span> =&gt; <span class="hljs-number">3</span> === <span class="hljs-number">5</span>) | <span class="hljs-type">guard</span> (<span class="hljs-keyword">_</span> =&gt; 'even stranger'),
  otherwise      | <span class="hljs-type">guard</span> (<span class="hljs-keyword">_</span> =&gt; 'ok'),
)</code></pre><p>If the guard functions return simple expressions, <code>guardV</code> can be more
convenient:</p>
<pre class="hljs"><code>cond (
  (<span class="hljs-name">_</span> =&gt; <span class="hljs-number">3</span> === <span class="hljs-number">4</span>) | guardV ('strange'),
  (_ =&gt; 3 === 5) | guardV ('even stranger'),
  otherwise      | guardV ('ok'),
)</code></pre><p>The most useful version is <code>condS</code>. Remember, &#39;S&#39; implies &#39;N&#39;, so give it an
array.</p>
<pre class="hljs"><code>const checkVal = val =&gt; val | <span class="hljs-type">condS</span> ([
  eq (<span class="hljs-number">4</span>)    | <span class="hljs-type">guard</span> (val =&gt; val | <span class="hljs-type">sprintf1</span> ('%s was <span class="hljs-number">4</span>')),
  lt (<span class="hljs-number">4</span>)    | <span class="hljs-type">guard</span> (val =&gt; val | <span class="hljs-type">sprintf1</span> ('%s was less than <span class="hljs-number">4</span>')),
  gt (<span class="hljs-number">4</span>)    | <span class="hljs-type">guard</span> (val =&gt; val | <span class="hljs-type">sprintf1</span> ('%s was more than <span class="hljs-number">4</span>')),
  otherwise | <span class="hljs-type">guardV</span> (<span class="hljs-string">"error, this shouldn't happen"</span>),
])</code></pre><p>Cleaning it up a bit, and inverting the parentheses in the test expressions:</p>
<pre class="hljs"><code>const checkVal = condS ([
  <span class="hljs-number">4</span> | eq    | guard  (<span class="hljs-name">sprintf1</span> ('%s was <span class="hljs-number">4</span>')),
  <span class="hljs-number">4</span> | lt    | guard  (<span class="hljs-name">sprintf1</span> ('%s was less than <span class="hljs-number">4</span>')),
  <span class="hljs-number">4</span> | gt    | guard  (<span class="hljs-name">sprintf1</span> ('%s was more than <span class="hljs-number">4</span>')),
  otherwise | guardV (<span class="hljs-string">"error, this shouldn't happen"</span>),
])</code></pre><p>Wut?! This does work, strange as it looks. Try it for yourself:</p>
<p>; [3, 4, 5]
| map (checkVal)
| join (&#39; | &#39;)
// 3 was less than 4 | 4 was 4 | 5 was more than 4</p>
<h3 id="٭-frontend-stuff-٭"><a class="header-link" href="#٭-frontend-stuff-٭"></a>٭ frontend stuff ٭</h3>
<pre class="hljs"><code><span class="hljs-keyword">import</span> { path, prop, whenTrue, always, } <span class="hljs-keyword">from</span> <span class="hljs-string">'stick-js'</span></code></pre><p>If you use react/redux, perhaps with saga, chances are your modules end in
something like this:</p>
<pre class="hljs"><code>const withConnect = connect(<span class="hljs-name">mapStateToProps</span>, mapDispatchToProps)<span class="hljs-comment">;</span>
const withReducer = injectReducer({ key: 'home', reducer })<span class="hljs-comment">;</span>
const withSaga = injectSaga({ key: 'home', saga })<span class="hljs-comment">;</span>

export default compose(
  <span class="hljs-name">withReducer</span>,
  withSaga,
  withConnect,
)(<span class="hljs-name">HomePage</span>)<span class="hljs-comment">;</span></code></pre><p>We should see by now that this composing of functions, invoked upon a single
value, is exactly our pipe pattern. So why not:</p>
<pre class="hljs"><code><span class="hljs-keyword">export</span> <span class="hljs-built_in">default</span> App
  | <span class="hljs-built_in">connect</span>       (mapStateToProps, mapDispatchToProps)
  | injectSaga    ({ key: <span class="hljs-string">'home'</span>, saga, })
  | injectReducer ({ key: <span class="hljs-string">'home'</span>, reducer, })</code></pre><p>And maybe you call actions using a structure like:</p>
<pre class="hljs"><code><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mapDispatchToProps</span>(<span class="hljs-params">dispatch</span>) </span>{
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">onChangeUsername</span>: <span class="hljs-function">(<span class="hljs-params">evt</span>) =&gt;</span> dispatch(changeUsername(evt.target.value)),
  };
};</code></pre><p>Why not:</p>
<pre class="hljs"><code><span class="hljs-keyword">export</span> const mapDispatchToProps = <span class="hljs-function"><span class="hljs-params">(dispatch)</span> =&gt;</span> ({
  onChangeUsername: path ([<span class="hljs-string">'target'</span>, <span class="hljs-string">'value'</span>] &gt;&gt; changeUsername &gt;&gt; dispatch,
})</code></pre><p>Try it yourself and see :D</p>
<p>If you use styled components, perhaps you pass optional props in. Checking
for the presence of the props can be annoying, so how about:</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> SomeElementS = styled.div<span class="hljs-string">`
  top: 5%;
  left: 5%;
  <span class="hljs-subst">${ prop (<span class="hljs-string">'width'</span>)  &gt;&gt; whenOk   (sprintf1 (<span class="hljs-string">'width: %spx;'</span>)) }</span>
  <span class="hljs-subst">${ prop (<span class="hljs-string">'height'</span>) &gt;&gt; whenOk   (sprintf1 (<span class="hljs-string">'height: %spx;'</span>)) }</span>
  <span class="hljs-subst">${ prop (<span class="hljs-string">'error'</span>)  &gt;&gt; whenTrue (<span class="hljs-string">'color: red;'</span> | always) }</span>
`</span>

&lt;SomeElementS width=<span class="hljs-string">'100%'</span> error={<span class="hljs-literal">true</span>} /&gt;</code></pre><p>If you use saga, perhaps you have something like this:</p>
<pre class="hljs"><code><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">getRepos</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> username = <span class="hljs-keyword">yield</span> select(makeSelectUsername());
  <span class="hljs-keyword">const</span> requestURL = <span class="hljs-string">`https://api.github.com/users/<span class="hljs-subst">${username}</span>/repos`</span>;

  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> repos = <span class="hljs-keyword">yield</span> call(request, requestURL);
    <span class="hljs-keyword">yield</span> put(reposLoaded(repos, username));
  } <span class="hljs-keyword">catch</span> (err) {
    <span class="hljs-keyword">yield</span> put(repoLoadingError(err));
  }
}</code></pre><p>How about this:</p>
<pre class="hljs"><code><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">getRepos</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> username = <span class="hljs-keyword">yield</span> makeSelectUsername () | select
  <span class="hljs-keyword">const</span> requestURL = username | sprintf1 (<span class="hljs-string">'https://api.github.com/users/%s/repos'</span>)
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> repos = <span class="hljs-keyword">yield</span> call (request, requestURL)
    reposLoaded (repos, username) | reposLoaded | put
  } <span class="hljs-keyword">catch</span> (err) {
    <span class="hljs-keyword">yield</span> err | repoLoadingError | put
  }
}</code></pre><p>Try it yourself and see :D</p>
<p>If you use reselect, this is fine:</p>
<pre class="hljs"><code>const selectHome = <span class="hljs-function"><span class="hljs-params">(state)</span> =&gt;</span> state.get(<span class="hljs-string">'home'</span>);
const makeSelectUsername = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> createSelector(
  selectHome,
  <span class="hljs-function"><span class="hljs-params">(homeState)</span> =&gt;</span> homeState.get(<span class="hljs-string">'username'</span>)
);</code></pre><p>But this is lit:</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> <span class="hljs-keyword">get</span> = dot1 (<span class="hljs-string">'get'</span>)

<span class="hljs-keyword">const</span> selectHome = <span class="hljs-keyword">get</span> (<span class="hljs-string">'home'</span>)
<span class="hljs-keyword">const</span> makeSelectUsername = () =&gt; createSelector(
  selectHome,
  <span class="hljs-keyword">get</span> (<span class="hljs-string">'username'</span>),
)</code></pre><p>When composing selectors, something like this works nicely to make sure the
one being composed is valid:</p>
<pre class="hljs"><code><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> makeSelectBooks = _ =&gt; createSelector (
  selectHome,
  <span class="hljs-keyword">get</span> (<span class="hljs-string">'books'</span>),
)

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> makeSelectBookTitles = _ =&gt; createSelector (
  makeSelectBooks (),
  <span class="hljs-string">'titles'</span> | <span class="hljs-keyword">get</span> | whenOk,
)</code></pre><p>The author uses stick idioms to slay a common front-end pattern. When you&#39;re
fetching your list of todos, the list should be <code>undefined</code> when it hasn&#39;t
been set yet, and empty only if it has been fetched and really is empty.
This makes testing easier, avoids weird flickers, lets you show a spinner,
etc. It does introduce an extra condition you need to test for in your code,
but we can handle this nicely:</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> ListS = styled.div<span class="hljs-string">`
  min-height: 150px;
`</span>

<span class="hljs-keyword">const</span> List = <span class="hljs-function">(<span class="hljs-params">{ children }</span>) =&gt;</span> &lt;ListS&gt;
  {children | ifOk (identity) (spinner)}
&lt;<span class="hljs-regexp">/ListS&gt;</span></code></pre><h3 id="٭-backend-stuff-٭"><a class="header-link" href="#٭-backend-stuff-٭"></a>٭ backend stuff ٭</h3>
<p>When you&#39;re using a framework like Express, you have the well-known <code>app</code>
object that you carry around everywhere. It just so happens that nearly all
methods of <code>app</code> return <code>app</code>, so that chaining works in the familiar way:</p>
<pre class="hljs"><code>app
<span class="hljs-selector-class">.use</span> (...)
<span class="hljs-selector-class">.all</span> (...)
<span class="hljs-selector-class">.post</span> (<span class="hljs-string">'/endpoint1'</span>, ((req, res) =&gt; ...))
<span class="hljs-selector-class">.patch</span> (<span class="hljs-string">'/endpoint2'</span>, ((req, res) =&gt; ...))
<span class="hljs-selector-class">.get</span> (<span class="hljs-string">'/endpoint3'</span>, ((req, res) =&gt; ...))
...
<span class="hljs-selector-class">.listen</span> (config<span class="hljs-selector-class">.port</span>, ...)</code></pre><p>But there are cases when the makers were not so thoughtful, or when you
simply don&#39;t know (or don&#39;t care) what a function or method returns. The
pipe will free you from the limitations of the dot, and allow you to compose
your own fluid interfaces. We&#39;ll use Express here to prove that it works.
See the raindrops example for how you might use this with WebGL, and there
are many other places this can be used.</p>
<pre class="hljs"><code><span class="hljs-keyword">import</span> { side1, side2, list, appendTo, } <span class="hljs-keyword">from</span> <span class="hljs-string">'stick-js'</span>
<span class="hljs-keyword">import</span> { fromPairs, } <span class="hljs-keyword">from</span> <span class="hljs-string">'ramda'</span>

<span class="hljs-keyword">const</span> get      = side2 (<span class="hljs-string">'get'</span>)
<span class="hljs-keyword">const</span> post     = side2 (<span class="hljs-string">'post'</span>)
<span class="hljs-keyword">const</span> patch    = side2 (<span class="hljs-string">'patch'</span>)
<span class="hljs-keyword">const</span> use      = side1 (<span class="hljs-string">'use'</span>)
<span class="hljs-keyword">const</span> all      = side2 (<span class="hljs-string">'all'</span>)
<span class="hljs-keyword">const</span> send     = side1 (<span class="hljs-string">'send'</span>)
<span class="hljs-keyword">const</span> status   = side1 (<span class="hljs-string">'status'</span>)
<span class="hljs-keyword">const</span> listen   = side2 (<span class="hljs-string">'listen'</span>)
<span class="hljs-keyword">const</span> sendJSON = side1 (<span class="hljs-string">'json'</span>)

<span class="hljs-keyword">const</span> sendStatus = <span class="hljs-function"><span class="hljs-params">code</span> =&gt;</span> data =&gt; status (code) &gt;&gt; sendJSON (data)
<span class="hljs-keyword">const</span> msg = appendTo ([<span class="hljs-string">'msg'</span>]) &gt;&gt; list &gt;&gt; fromPairs

app | use (bodyParser.json())
    | all (<span class="hljs-string">'*'</span>, (req, res, next) =&gt; {
      ...
        next ()
    })

    | post (<span class="hljs-string">'/endpoint1'</span>, (<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {
      ...
      res | sendStatus (<span class="hljs-number">500</span>) (<span class="hljs-string">'Server error'</span> | msg)
    }))

    | patch (<span class="hljs-string">'/endpoint2'</span>, (<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {
      ...
      res | sendStatus (<span class="hljs-number">200</span>) ({ results, })
    }))

    ...

    | get (<span class="hljs-string">'/endpoint3'</span>, (<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> ...))

    | listen (config.port) (...)</code></pre><h3 id="٭-cond-٭-1"><a class="header-link" href="#٭-cond-٭-1"></a>٭ cond ٭</h3>
<pre class="hljs"><code><span class="hljs-keyword">import</span> {
  <span class="hljs-built_in">map</span>, <span class="hljs-built_in">join</span>, condS, guard, otherwise,
  sprintfN, rangeTo, lt, gt, tap, appendTo, prop,
} from <span class="hljs-string">'stick-js'</span>

<span class="hljs-keyword">import</span> { curry, }              from <span class="hljs-string">'ramda'</span>
<span class="hljs-keyword">import</span> { yellow, <span class="hljs-built_in">green</span>, <span class="hljs-built_in">red</span>, } from <span class="hljs-string">'chalk'</span>

<span class="hljs-keyword">const</span> { <span class="hljs-built_in">log</span>, } = console

<span class="hljs-keyword">const</span> cmpStr = curry ((<span class="hljs-built_in">str</span>, <span class="hljs-built_in">color</span>, tgtStr, x) =&gt; [x, <span class="hljs-built_in">str</span> | <span class="hljs-built_in">color</span>, tgtStr]
  | sprintfN (<span class="hljs-string">'%s is %s %s'</span>)
)

<span class="hljs-keyword">const</span> lessThanStr     = cmpStr (<span class="hljs-string">'less than'</span>, yellow)
<span class="hljs-keyword">const</span> greaterThanStr  = cmpStr (<span class="hljs-string">'greater than'</span>, <span class="hljs-built_in">red</span>)
<span class="hljs-keyword">const</span> inBetweenString = ([ low, high ]) =&gt; cmpStr (<span class="hljs-string">'in between'</span>, <span class="hljs-built_in">green</span>, [low, high] | <span class="hljs-built_in">join</span> (<span class="hljs-string">' and '</span>))

<span class="hljs-comment">// --- this is intentionally complex for illustration</span>
<span class="hljs-keyword">const</span> getCmpStr = curry ((low, high, x) =&gt; x
  | condS ([
    low  | lt | guard ((low | lessThanStr)           &gt;&gt; appendTo ([<span class="hljs-number">-1</span>])),
    high | gt | guard ((high | greaterThanStr)       &gt;&gt; appendTo ([<span class="hljs-number">1</span>])),
    otherwise | guard (inBetweenString ([low, high]) &gt;&gt; appendTo ([<span class="hljs-number">0</span>])),
  ])
)

<span class="hljs-keyword">const</span> inRange = ([low, high]) =&gt; x =&gt; getCmpStr (low, high, x)

<span class="hljs-keyword">const</span> snd = prop (<span class="hljs-number">1</span>)
<span class="hljs-keyword">const</span> fst = prop (<span class="hljs-number">0</span>)

<span class="hljs-number">10</span> | rangeTo (<span class="hljs-number">20</span>)             <span class="hljs-comment">// [10, 11, ... 19]</span>
   | <span class="hljs-built_in">map</span> (inRange ([<span class="hljs-number">13</span>, <span class="hljs-number">17</span>])) <span class="hljs-comment">// maps to tuples of [int, str]</span>
   | tap (<span class="hljs-built_in">map</span> (snd &gt;&gt; <span class="hljs-built_in">log</span>))   <span class="hljs-comment">// logs the str</span>
   | <span class="hljs-built_in">map</span> (fst)                <span class="hljs-comment">// [-1, -1, ... 0, ... 1, 1]</span></code></pre><h2 id="performance"><a class="header-link" href="#performance"></a>performance</h2>
<p>Stick is fast. See here for a benchmark of our factory example.</p>
<p>Though it initially depended on Ramda, we have decided to eliminate that
dependency by reimplementing many of the functions. While profiling the
WebGL example we found that even trivial functions like <code>R.flip</code> and <code>R.tap</code>
are surprisingly expensive.</p>
<p>This really only becomes an issue in critical loops -- an inner loop of a
socket or server, an animation, a particle system where lots of objects are
spawned per second, WebGL. For cases like these, see below.</p>
<p>It is true that <code>a | b</code> compiles to three function calls, whereas <code>b (a)</code> is
only one. But this is almost certainly not going to affect your app. Your JS
runtime can call <em>a lot</em> of functions per millisecond.</p>
<p>Nonetheless you are encouraged to mix and match our functions with whichever
functional libraries you like -- Ramda, Lodash/FP, or anything else, as it
suits you.</p>
<pre class="hljs"><code><span class="hljs-keyword">import</span> { map, } <span class="hljs-keyword">from</span> <span class="hljs-string">'ramda'</span>
<span class="hljs-keyword">import</span> { filter, } <span class="hljs-keyword">from</span> <span class="hljs-string">'lodash/fp'</span>
<span class="hljs-keyword">import</span> { ifPredicate, } <span class="hljs-keyword">from</span> <span class="hljs-string">'stick-js'</span></code></pre><p>The stick idiom will still work, as long as the functions are curried and
data-last.</p>
<p>Furthermore Ramda is probably perfectly fine for your app, and its functions
often provide type-checking and error messages (we don&#39;t), and many of their
functions are more sophisticated. <code>R.map</code> works on functors and
transformers, for example -- ours doesn&#39;t.</p>
<p>And, it is our belief that if you are already using the <code>flow</code> pattern in
Lodash/FP or the <code>pipe</code> function in Ramda, that it will really be a
no-brainer to overload the operator and keep everything else the same.</p>
<pre class="hljs"><code><span class="hljs-symbol">_</span>.flow (
  <span class="hljs-symbol">_</span>.<span class="hljs-built_in">split</span> (' '),
  <span class="hljs-symbol">_</span>.<span class="hljs-built_in">map</span> (capitaliseFirstLetter),
  <span class="hljs-symbol">_</span>.<span class="hljs-built_in">join</span> (' '),
) (myData)

// -&gt;
myData
| <span class="hljs-symbol">_</span>.<span class="hljs-built_in">split</span> (' '),
| <span class="hljs-symbol">_</span>.<span class="hljs-built_in">map</span> (capitaliseFirstLetter),
| <span class="hljs-symbol">_</span>.<span class="hljs-built_in">join</span> (' ')</code></pre><p>merge benchmark: manual / index / ramda</p>
<h2 id="extra-performance"><a class="header-link" href="#extra-performance"></a>Extra performance</h2>
<p>For speed freaks: the curried functions you import from the main module are
written first using manual currying, and then recurried and exported. This
is in order to allow both calling styles.</p>
<p>For a speed boost you can check the docs to see if your function is exported
by &#39;stick-js/manual&#39;. If so, you can directly import the manual version, but
you must remember to call it using the manual style:</p>
<pre class="hljs"><code>import { merge, } from <span class="hljs-string">'stick-js/manual'</span>
merge <span class="hljs-comment">(obj1, obj2)</span> <span class="hljs-comment">// will not work</span>
obj<span class="hljs-number">2</span> | merge <span class="hljs-comment">(obj1)</span> <span class="hljs-comment">// ok</span>
merge <span class="hljs-comment">(obj1)</span> <span class="hljs-comment">(obj2)</span> <span class="hljs-comment">// also ok</span></code></pre><h2 id="generic-version-of-`lets`"><a class="header-link" href="#generic-version-of-`lets`"></a>Generic version of <code>lets</code></h2>
<p>Here is a generic form of <code>lets</code> which takes any number of non-zero
arguments. We removed it from stick because it depends on <code>mapAccum</code>, for
which we do not currently have an implementation without depending on Ramda.</p>
<pre class="hljs"><code><span class="hljs-comment">// --- generic form, for any non-zero number of arguments.</span>
<span class="hljs-keyword">const</span> lets = <span class="hljs-function">(<span class="hljs-params">...xs</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> executeStep = <span class="hljs-function"><span class="hljs-params">prevVals</span> =&gt;</span> applyToN (prevVals)

    <span class="hljs-keyword">const</span> ys = xs
        <span class="hljs-comment">// --- acc contains running output array, up to the previous item.</span>
        | mapAccum (<span class="hljs-function">(<span class="hljs-params">acc, v</span>) =&gt;</span> executeStep (acc) (v)
            | (<span class="hljs-function"><span class="hljs-params">stepVal</span> =&gt;</span> [[...acc, stepVal], stepVal])
        ) ([])
        | prop (<span class="hljs-number">1</span>)

    <span class="hljs-keyword">return</span> ys | last
}</code></pre><p>Note: this is not fast, but it is correct. You can prove it with a 
contrived fibonacci example:</p>
<pre class="hljs"><code><span class="hljs-keyword">import</span> { list, timesV, applyToN, rangeTo, } <span class="hljs-keyword">from</span> <span class="hljs-string">'stick-js'</span>

<span class="hljs-keyword">const</span> fibonacci = <span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> sumLastTwo = <span class="hljs-function">(<span class="hljs-params">xs</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> l = xs.length
    <span class="hljs-keyword">return</span> xs [l<span class="hljs-number">-1</span>] + xs [l<span class="hljs-number">-2</span>]
  }
  <span class="hljs-keyword">const</span> entry = <span class="hljs-function">(<span class="hljs-params">...prev</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> l = prev.length
    <span class="hljs-keyword">return</span> l === <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> :
           l === <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : sumLastTwo (prev)
  }
  <span class="hljs-keyword">const</span> refs = entry | timesV (n + <span class="hljs-number">1</span>)
  <span class="hljs-keyword">const</span> args = [...refs, list]
  <span class="hljs-keyword">return</span> lets (...args)
}

<span class="hljs-number">1</span> | rangeTo (<span class="hljs-number">20</span>)
  | map (fibonacci)

<span class="hljs-comment">/*
  [ [ 1, 1 ],
    [ 1, 1, 2 ],
    [ 1, 1, 2, 3 ],
    [ 1, 1, 2, 3, 5 ],
    [ 1, 1, 2, 3, 5, 8 ],
    [ 1, 1, 2, 3, 5, 8, 13 ],
    [ 1, 1, 2, 3, 5, 8, 13, 21 ],
    [ 1, 1, 2, 3, 5, 8, 13, 21, 34 ],
    [ 1, 1, 2, 3, 5, 8, 13, 21, 34, 55 ]
    ...
  ]
*/</span></code></pre><h2 id="bitwise-math"><a class="header-link" href="#bitwise-math"></a>Bitwise math</h2>
<p>Of course, we&#39;ve saved your precious bitwise operators. You can either:</p>
<ol class="list">
<li><p>Use the functional form</p>
<pre class="hljs"><code> <span class="hljs-keyword">import</span> { bitwiseOr, bitwiseShiftBy, } <span class="hljs-keyword">from</span> <span class="hljs-string">'stick-js'</span>
 <span class="hljs-number">4</span> | bitwiseOr (<span class="hljs-number">9</span>) <span class="hljs-comment">// 13</span></code></pre></li>
<li><p>Do your bitwise math in a separate scope than that in which the
<code>defineBinaryOperator</code> calls appear. The operators are only overloaded in
the scope in which the calls are made. We recommend doing the bitwise math
in a separate source file and not mixing the two styles in one file.</p>
</li>
</ol>
<h2 id="why-not-use-lodash?-/-ramda/-etc."><a class="header-link" href="#why-not-use-lodash?-/-ramda/-etc."></a>Why not use lodash? / ramda/ etc.</h2>
<ul class="list">
<li>you don&#39;t need to carry around the _</li>
<li>free functions are far more flexible than dotted ones</li>
<li>predictable semantics based on English</li>
<li>prototype stuff</li>
</ul>
</body>
</html>
